{"componentChunkName":"component---node-modules-ocular-gatsby-src-templates-search-jsx","path":"/search","webpackCompilationHash":"abf821557dd02f231f0c","result":{"pageContext":{"isCreatedByStatefulCreatePages":false,"data":[{"excerpt":"Introduction math.gl is a JavaScript class library for 3D and geospatial math. It provides traditional 3D library classes for vectors…","rawMarkdownBody":"# Introduction\n\nmath.gl is a JavaScript class library for 3D and geospatial math. It provides traditional 3D library classes for vectors, matrices etc, as well as additional, optional modules that address different domains.\n\n## Available Modules\n\n- `math.gl`: Basic 3D math classes (vectors, matrices etc) and utilities (`equals`, `toRadians` etc).\n- `@math.gl/geospatial` - support for geospatial math, primarily WGS84 and Web Mercator.\n\n## Class Library Features\n\n- **Classes for gl-matrix** - math.gl classes are built on top of `gl-matrix`. `gl-matrix` has a reputation for being the most performant and battle-tested JavaScript math library around.\n\n- **Array-Based** - math.gl classes (like `Vector3`, `Matrix4`) are subclasses of the built-in JavaScript `Array` which enables applications to use them interchangeably with plain (or typed) arrays.\n\n- **Debug Friendly** - math.gl offers **optional** error checking after every math operation which makes quick work of locating coding errors and bad input data. Printing support for objects (`toString`) also simplifies debugging.\n\n- **Documentation** - If you are new to 3D programming it can be hard to know where to start. math.gl comes with articles to show you the big picture and get you up-to-speed on the mathematical concepts and the corresponding classes.\n\n- **Size Conscious** - math.gl is published as multiple modules to let applications cherry-pick required functionality, and is optimizes dependencies for tree-shaking to make sure you only pay for (bundle) what you use.\n\n## Supported Browsers and Node Versions\n\nmath.gl is fully supported on:\n- \"evergreen\" browsers: i.e recent versions of Chrome, Safari, Firefox, Edge etc.\n- Node.js\n- IE11: math.gl's fully transpiled `es5` distribution shuold work (with performance caveats).\n\nHowever, Internet Explorer < 10 will not work. If your application needs to support non-evergreen browsers, an option could be to use e.g. `gl-matrix` directly.\n\n## Key Design Ideas\n\n- ES6 allows JavaScript classes to be derived from the built-in arrays\n- gl-matrix provides high-performance math that works directly on arrays.\n- Geospatial frameworks like deck.gl and mapbox-gl expect vectors to be supplied in the form of JavaScript arrays.\n\n## History\n\n- The core classes were originally developed as part of luma.gl v4 to provide a basic 3D math library for the luma.gl and deck.gl frameworks.\n- math.gl was then broken out into its own module to allow it to mature in terms of functionality and stability.\n- Through a collaboration with the Cesium team, parts of the Cesium math library are ported and published as independently usable math.gl modules (geospatial and culling).\n\n## Roadmap\n\n- The intention is that math.gl should be able to serve a general purpose 3D math library.\n- math.gl modules (such as geospatial math) should be usable by applications using other frameworks, without having to use the core math.gl classes.\n\n## Attributions\n\nmath.gl was inspired by and built upon some of the most proven open source JavaScript math libraries:\n\n- [`gl-matrix`](http://glmatrix.net/) - math.gl classes use gl-matrix under the hood\n- THREE.js math library - math.gl classes are API-compatible with a subset of the THREE.js classes and pass THREE.js test suites.\n- Cesium math library (Apache2) - The geospatial and culling modules were ported from Cesium code base.\n\n## License\n\nMIT license. The libraries that the core `math.gl` module are built on (e.g. gl-matrix) are also all open source and MIT licensed.\n\nThe `@math.gl/geospatial` and `@math.gl/culling` include Cesium-derived code which is Apache2 licensed.\n","slug":"docs","title":"Introduction"},{"excerpt":"Upgrade Guide Upgrading to v3.0 Matrix API changes Matrix setter functions no longer support ommitted parameters. (Motivation: Increased API…","rawMarkdownBody":"# Upgrade Guide\n\n## Upgrading to v3.0\n\n#### Matrix API changes\n\n* Matrix setter functions no longer support ommitted parameters. (Motivation: Increased API rigor, improved debugging and library compactness).\n\n#### `Matrix` transforms now return `Array`s by default\n\nThe `Matrix4` and `Matrix3` classes no longer by default create new `Vector2`, `Vector3` and `Vector4` instances. Instead they create standard JavaScript arrays.\n\nPreviously a new `Vector4` would be allocated if no `result` parameter was provided.\n```js\nimport {Matrix4, Vector4} from 'math.gl';\nconst vector = new Matrix4().transform([0, 0, 0, 1]);\nassert(vector instanceof Vector4);\n```\n\nNow a plain JavaScript `Array` is allocated\n```js\nimport {Matrix4} from 'math.gl';\nconst vector = new Matrix4().transform([0, 0, 0, 1]);\nassert(vector instanceof Array);\n```\n\nThe old behavior can be restored by providing the result parameter\n```js\nimport {Matrix4, Vector4} from 'math.gl';\nconst vector = new Matrix4().transform([0, 0, 0, 1], new Vector4());\nassert(vector instanceof Vector4);\n```\n\nMotivation: This change reduces dependencies between math.gl core classes which improves tree-shaking and bundle sizes.\n\n### Matrix setter functions no longer support ommitted parameters\n\nMotivation: This change increases rigor, facilitates debugging, and improves library compactness, and the use case for default parameters was questionable.\n\n#### Deprecations\n\n| Method | Replacement | Reason |\n| --- |  --- | --- |\n| `Matrix*.setColumnMajor`     | `Matrix*.set`               | API simplification |\n| `Matrix4.transformPoint`     | `Matrix4.transform`         | Name alignment |\n| `Matrix4.transformVector`    | `Matrix4.transform`         | Name alignment |\n| `Matrix4.transformDirection` | `Matrix4.transformAsVector` | Name alignment |\n| `Matrix3.transformVector`    | `Matrix3.transform`         | Name alignment |\n| `Matrix3.transformVector2`   | `Matrix3.transform`         | Generalize |\n| `Matrix3.transformVector3`   | `Matrix3.transform`         | Generalize |\n\n#### Removals\n\n| Method | Replacement | Reason |\n| --- | --- | --- |\n| `Vector2.cross` | `Vector3.cross` | Cross products by definition work on 3 dimensional vectors. |\n\n\n## Upgrading to v2.0\n\nExperimental exports are now exported with a leading underscore (\\_), instead of as members of the `experimental` namespace:\n\nNOW: math.gl v2\n```js\nimport {_Euler as Euler} from 'math.gl';\n```\n\nBEFORE: math.gl v1.x\n```js\nimport {experimental} from 'math.gl';\nconst {Euler} = experimental;\n```\n\nThe `experimental` name space export has been removed.\n\n## Upgrading to v1.1\n\n### Removed Functionality\n\nThe `Euler` class is no longer included as an experimental export. It would need to be imported from the `dist` folder.\n","slug":"docs/upgrade-guide","title":"Upgrade Guide"},{"excerpt":"What's New v3.0 (In Development) Date: Aug 8, 2019 Website Benchmarks and Performance Improvements A benchmarking example has been added to…","rawMarkdownBody":"# What's New\n\n## v3.0 (In Development)\n\nDate: Aug 8, 2019\n\n### Website Benchmarks and Performance Improvements\n\nA [benchmarking example](https://math.gl/examples/benchmarks) has been added to the website that makes it easy to assess the performance of the math.gl library on your own browser. The math.gl library has been carefully tuned based on these benchmarks and performance of the library has been significantly improved over version 2.x.\n\n### `@math.gl/geospatial`\n\nA new module (developed in collaboration with the Cesium engineering team) providing WebGL-framework-independent geospatial math classes and algorithms:\n\n- New class `Ellipsoid` and constant `Ellipsoid.WGS84` for working with WSG84 coordinates\n\n### `@math.gl/culling`\n\nA new module (developed in collaboration with the Cesium engineering team) providing WebGL-framework-independent classesthat support geometric intersection calculations (primarily intended to support frustum culling operations):\n\n- New class `AxisAlignedBoundingBox`\n- New class `OrientedBoundingBox`\n- New class `BoundingSphere`\n- New class `CullingVolume`\n\n### `math.gl` - Core module additions\n\n#### Transform API Consolidation\n\nThe API for transformations (i.e. multiplying vectors with matrices or quaternions) has been extended and made more orthogonal:\n\n- The `transform*` methods are now available on all `Vector` classes, in addition to on the `Matrix` classes. Among other things, this enables transformations without using `Matrix` classes.\n- Naming consistency of transform methods across classes (`transform`, `transformAsPoint`, `transformAsVector`).\n- Alternative transform methods added to the `Vector` classes (`transformByMatrix3`, `transformByMatrix2`, `transformByMatrix2x3` and `transformByQuaternion`). Simplifies using the most efficient transformation for the job.\n\n#### Matrix classes\n\n- New methods `Matrix*.setColumn()` and `Matrix*.getColumn()`\n- New method `Matrix*.toString()`\n- Improved method: `Matrix4.frustum()` now supports infinite `far` plane (parity with `Matrix4.perspective`, which already supported this).\n\n#### Utility Functions\n\n- New: global functions `toRadians` and `toDegrees`\n- New: global function `exactEqual`\n\n## v2.3\n\nDate: Jan 29, 2019\n\n- New class: `Matrix3`\n- New: Add `scale` factor support to `Matrix3` and `Matrix4`\n- Support quaternion to euler conversion\n- Now uses the official `gl-matrix@3.0.0` package as dependency instead of forked gl-matrix packages.\n\n## v2.2\n\nDate: Sep 20, 2018\n\n- Use `@babel/runtime` to reduce bundle size\n- `equals` function fix on arrays\n\n## v2.0\n\nDate: June 25, 2018\n\n### New Naming Convention for Experimental Exports\n\nExperimental exports are now exported with a leading underscore (\\_), instead of as members of the `experimental` namespace.\n\nThe change was made to make it possible for tree-shaking bundlers to remove unused experimental exports from applications.\n\n\n## v1.2\n\nDate: May 4, 2018\n- New `lerp` utility\n- Experimental `Pose` class\n\n\n## v1.1\n\nDate: April 16, 2018\n\n### Matrix4 Improvements\n\n**`Matrix4.orthographic()`** - To simplify switching between perspective and orthographic views, math.gl now offers an additional method for creating orthographic projection matrix, that takes the same parameters as `Matrix4.perspective()`, with the addition of one additional parameter, `focalDistance`. See [`Matrix4.orthographic`](docs/api-reference/matrix4)`({fovy, aspect, focalDistance, near, far})`\n\n\n### Bundle Size Reduction\n\nmath.gl has been tuned to have approximately 20% smaller footprint when bundled in applications.\n\n\n### THREE.js Compatibility\n\nmath.gl classes now pass large parts of the THREE.js test suite, which should make it easier to reuse code written for the THREE.js math library.\n\n\n## v1.0\n\nDate: Jan 9, 2018\n\nInitial release.\n","slug":"docs/whats-new","title":"What's New"},{"excerpt":"math.gl math.gl is a suite of math modules for 3D applications. This module contains classes for vectors and matrices etc. For documentation…","rawMarkdownBody":"# math.gl\n\n[math.gl](https://math.gl/docs) is a suite of math modules for 3D applications.\n\nThis module contains classes for vectors and matrices etc.\n\nFor documentation please visit the [website](https://math.gl).\n","slug":"modules/core","title":"math.gl"},{"excerpt":"@math.gl/geospatial math.gl is a suite of math modules for 3D and geospatial applications. This module contains geospatial math, for dealing…","rawMarkdownBody":"# @math.gl/geospatial\n\n[math.gl](https://math.gl/docs) is a suite of math modules for 3D and geospatial applications.\n\nThis module contains geospatial math, for dealing with the WGS84 (World Geodetic System) coordinate system etc.\n\nFor documentation please visit the [website](https://math.gl).\n","slug":"modules/geospatial","title":"@math.gl/geospatial"},{"excerpt":"BoundingSphere A bounding sphere with a center and a radius. Usage Create a bounding sphere around the unit cube Sort bounding spheres from…","rawMarkdownBody":"# BoundingSphere\n\nA [bounding sphere](https://en.wikipedia.org/wiki/Bounding_sphere) with a center and a radius.\n\n## Usage\n\nCreate a bounding sphere around the unit cube\n```js\nimport {BoundingSphere} from '@math.gl/culling';\ncont sphere = new BoundingSphere().fromCornerPoints(\n  [-0.5, -0.5, -0.5],\n  [0.5, 0.5, 0.5]\n);\n```\n\nSort bounding spheres from back to front\n```js\nimport {BoundingSphere} from '@math.gl/culling';\nconst spheres = [new BoundingSphere(...), new BoundingSphere(...), ...];\nconst cameraPosWC = ...;\nspheres.sort(\n  (a, b) => b.distanceSquaredTo(b, cameraPosWC) - a.distanceSquaredTo(a.cameraPosWC)\n);\n```\n\n## Global Functions\n\n#### makeBoundingSphereFromPoints(positions : iterator, result? : BoundingSphere) : BoundingSphere\n\nComputes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points. The bounding sphere is computed by running two algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to ensure a tight fit.\n\n- `positions` An iterable (e.g. array) of points that the bounding sphere will enclose. Each point must have `x`, `y`, and `z` properties.\n- `result` Optional object onto which to store the result.\n\nReturns\n- The modified `result` parameter or a new `BoundingSphere` instance if one was not provided.\n\nSee [Bounding Sphere computation article](http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/)\n\n\n## Fields\n\n### center : Vector3\n\nThe center point of the sphere.\n\n### radius : Number\n\nThe radius of the sphere.\n\n\n\n## Members\n\n### constructor(center : Number[3], radius : Number)\n\nCreates a new `BoundingSphere`\n\n- `center`=`[0, 0, 0]` The center of the bounding sphere.\n- `radius`=`0.0` The radius of the bounding sphere.\n\n#### fromCenterRadius(center : Number[3], radius : Number) : BoundingSphere\n\nSets the `BoundingSphere` from center and radius\n\n- `center`=`[0, 0, 0]` The center of the bounding sphere.\n- `radius`=`0.0` The radius of the bounding sphere.\n\n#### fromCornerPoints(corner : Number[3], oppositeCorner : Number[3], result? : BoundingSphere) : BoundingSphere\n\nComputes a bounding sphere from the two corner points of an axis-aligned bounding box.  The sphere tighly and fully encompases the box.\n\n- `corner` The minimum height over the rectangle.\n- `oppositeCorner` The maximum height over the rectangle.\n\n#### fromBoundingSpheres(boundingSpheres : BoundingSphere[]) : BoundingSphere\n\nComputes a tight-fitting bounding sphere enclosing the provided array of bounding spheres.\n\n- `boundingSpheres` The array of bounding spheres.\n\nReturns\n- The modified `result` parameter or a new `BoundingSphere` instance if none was provided.\n\n#### clone()\n\nDuplicates a `BoundingSphere` instance.\n\nReturns\n- A new `BoundingSphere` instance\n\n#### equals(right : BoundingSphere) Boolean\n\nCompares the provided `BoundingSphere` componentwise and returns `true` if they are equal, `false` otherwise.\n\n- `right` The second `BoundingSphere`.\n\nReturns\n- `true` if left and right are equal, `false` otherwise.\n\n#### union(right : BoundingSphere) : BoundingSphere\n\nComputes a bounding sphere that contains both the this and the `right` bounding spheres.\n\n- `right` The second `BoundingSphere`.\n\n#### expand(point : Number[3]) : BoundingSphere\n\nComputes a bounding sphere by enlarging the provided sphere to contain the provided point.\n\n- `point` A point to enclose in a bounding sphere.\n\n#### intersectPlane(plane : Plane) : Intersect\n\nDetermines which side of a plane a sphere is located.\n\n- `plane` The plane to test against.\nReturns\n- `Intersect.INSIDE` if the entire sphere is on the side of the plane the normal is pointing\n- `Intersect.OUTSIDE` if the entire sphere is on the opposite side\n- `Intersect.INTERSECTING` if the sphere intersects the plane.\n\n#### transform(transform : Number[16]) : BoundingSphere\n\nApplies a 4x4 affine transformation matrix to a bounding sphere.\n\n- `transform` The transformation matrix to apply to the bounding sphere.\n\n#### distanceSquaredTo(point) : Number\n\nComputes the estimated distance squared from the closest point on a bounding sphere to a point.\n\n- `point` The point\n\nReturns\n- The estimated distance squared from the bounding sphere to the point.\n\n\n##### transformWithoutScale(sphere, transform, result)\n\nApplies a 4x4 affine transformation matrix to a bounding sphere where there is no scale\nThe transformation matrix is not verified to have a uniform scale of 1.\nThis method is faster than computing the general bounding sphere transform using {@link BoundingSphere.transform}.\n\n@param {BoundingSphere} sphere The bounding sphere to apply the transformation to.\n@param {Matrix4} transform The transformation matrix to apply to the bounding sphere.\n- `result` Optional object onto which to store the result.\n\nReturns\n- The modified `result` parameter or a new `BoundingSphere` instance if none was provided.\n\n@example\nvar modelMatrix = Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid);\nvar boundingSphere = new BoundingSphere();\nvar newBoundingSphere = BoundingSphere.transformWithoutScale(boundingSphere, modelMatrix);\n\n\n#### computePlaneDistances (sphere, position, direction, result)\n\nThe distances calculated by the vector from the center of the bounding sphere to position projected onto direction plus/minus the radius of the bounding sphere.\n\nIf you imagine the infinite number of planes with normal direction, this computes the smallest distance to the closest and farthest planes from position that intersect the bounding sphere.\n\n@param {BoundingSphere} sphere The bounding sphere to calculate the distance to.\n@param {Cartesian3} position The position to calculate the distance from.\n@param {Cartesian3} direction The direction from position.\n@param {Interval} [result] A Interval to store the nearest and farthest distances.\n@returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.\n\n\n#### projectTo2D(sphere, projection, result)\n\nCreates a bounding sphere in 2D from a bounding sphere in 3D world coordinates.\n\n@param {BoundingSphere} sphere The bounding sphere to transform to 2D.\n@param {Object} [projection=GeographicProjection] The projection to 2D.\n- `result` Optional object onto which to store the result.\n\nReturns\n- The modified `result` parameter or a new `BoundingSphere` instance if none was provided.\n\n## Attribution\n\nThis class was ported from [Cesium](https://github.com/AnalyticalGraphicsInc/cesium) under the Apache 2 License.\n","slug":"modules/culling/docs/api-reference/bounding-sphere","title":"BoundingSphere"},{"excerpt":"WIP BoundingSphere.fromOrientedBoundingBox = function(orientedBoundingBox, result) {\nComputes a tight-fitting bounding sphere enclosing the…","rawMarkdownBody":"## WIP\n\nBoundingSphere.fromOrientedBoundingBox = function(orientedBoundingBox, result) {\nComputes a tight-fitting bounding sphere enclosing the provided oriented bounding box.\n\n@param {OrientedBoundingBox} orientedBoundingBox The oriented bounding box.\n- `result` Optional object onto which to store the result.\n\nReturns\n- The modified `result` parameter or a new `BoundingSphere` instance if none was provided.\n\nComputes a tight-fitting bounding sphere enclosing the provided oriented bounding box.\n\n@param {OrientedBoundingBox} orientedBoundingBox The oriented bounding box.\n- `result` Optional object onto which to store the result.\n\nReturns\n- The modified `result` parameter or a new `BoundingSphere` instance if none was provided.\n\n    BoundingSphere.fromRectangle2D = function(rectangle, projection, result) {\nComputes a bounding sphere from a rectangle projected in 2D.\n\n@param {Rectangle} [rectangle] The rectangle around which to create a bounding sphere.\n@param {Object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n- `result` Optional object onto which to store the result.\n\nReturns\n- The modified `result` parameter or a new `BoundingSphere` instance if none was provided.\n\n    BoundingSphere.fromRectangleWithHeights2D = function(rectangle, projection, minimumHeight, maximumHeight, result) {\nComputes a bounding sphere from a rectangle projected in 2D.  The bounding sphere accounts for the\nobject's minimum and maximum heights over the rectangle.\n\n@param {Rectangle} [rectangle] The rectangle around which to create a bounding sphere.\n@param {Object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.\n- `minimumHeight`=0.0 The minimum height over the rectangle.\n- `maximumHeight`=0.0 The maximum height over the rectangle.\n- `result` Optional object onto which to store the result.\n\nReturns\n- The modified `result` parameter or a new `BoundingSphere` instance if none was provided.\n\n    BoundingSphere.fromRectangle3D = function(rectangle, ellipsoid, surfaceHeight, result) {\nComputes a bounding sphere from a rectangle in 3D. The bounding sphere is created using a subsample of points\non the ellipsoid and contained in the rectangle. It may not be accurate for all rectangles on all types of ellipsoids.\n\n@param {Rectangle} [rectangle] The valid rectangle used to create a bounding sphere.\n@param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid used to determine positions of the rectangle.\n- `surfaceHeight`=0.0 The height above the surface of the ellipsoid.\n- `result` Optional object onto which to store the result.\n\nReturns\n- The modified `result` parameter or a new `BoundingSphere` instance if none was provided.\n","slug":"modules/culling/wip/bounding-sphere","title":" WIP"},{"excerpt":"OrientedBoundingBox An OrientedBoundingBox is a closed and convex cuboid. It can provide a tighter bounding volume than a bounding sphere or…","rawMarkdownBody":"# OrientedBoundingBox\n\nAn OrientedBoundingBox is a closed and convex cuboid. It can provide a tighter bounding volume than a bounding sphere or an axis aligned bounding box in many cases.\n\n# Usage\n\nCreate an OrientedBoundingBox using a transformation matrix, a position where the box will be translated, and a scale.\n\n```js\nimport {Vector3} from 'math.gl';\nimport {OrientedBoundingBox} from '@math.gl/culling';\n\nconst center = new Vector3(1.0, 0.0, 0.0);\nconst halfAxes = new Matrix3().fromScale([1.0, 3.0, 2.0]);\nconst box = new OrientedBoundingBox(center, halfAxes);\n```\n\nSort bounding boxes from back to front\n\n```js\nboxes.sort(\n  (boxA, boxB) =>\n    boxB.distanceSquaredTo(camera.positionWC) - boxA.distanceSquaredTo(camera.positionWC)\n);\n```\n\nCompute an oriented bounding box enclosing two points.\n\n```js\n// import {makeBoundingBoxFromPoints} from '@math.gl/culling';\nconst box = makeBoundingBoxFromPoints([[2, 0, 0], [-2, 0, 0]]);\n```\n\n## Global Functions\n\n### makeBoundingBoxFromPoints(positions : Array[3][]) : OrientedBoundingBox\n\nComputes an instance of an OrientedBoundingBox of the given positions.\nThis is an implementation of Stefan Gottschalk's [Collision Queries using Oriented Bounding Boxes](http://gamma.cs.unc.edu/users/gottschalk/main.pdf) (PHD thesis).\n\n- `positions` List of `Vector3` points that the bounding box will enclose.\n\n### makeBoundingBoxfromRectangle(rectangle : Rectangle [, minimumHeight : Number, maximumHeight : Number, ellipsoid : Ellipsoid]) : OrientedBoundingBox\n\nComputes an `OrientedBoundingBox` that bounds a `Rectangle` on the surface of an `Ellipsoid`.\n\nThere are no guarantees about the orientation of the bounding box.\n\n- `rectangle` The cartographic rectangle on the surface of the ellipsoid.\n- `minimumHeight`=`0.0` The minimum height (elevation) within the tile.\n- `maximumHeight`=`0.0` The maximum height (elevation) within the tile.\n- `ellipsoid`=`Ellipsoid.WGS84` The ellipsoid on which the rectangle is defined.\n- `result` The object onto which to store the result.\n\nReturns\n\n- The modified result parameter or a new `OrientedBoundingBox` instance if none was provided.\n\nThrows\n\n- `rectangle.width` must be between 0 and pi.\n- `rectangle.height` must be between 0 and pi.\n- `ellipsoid` must be an ellipsoid of revolution (`radii.x == radii.y`)\n\n## Fields\n\n### center: Vector3 = [0, 0, 0]\n\nThe center position of the box.\n\n### halfAxes: Matrix3\n\nThe transformation matrix, to rotate the box to the right position.\n\n## Methods\n\n### constructor(center = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {\n\n### constructor\n\n- {Vector3} [center=Vector3.ZERO] The center of the box.\n- {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box. Equivalently, the transformation matrix, to rotate and scale a cube centered at the origin.\n\n### clone() : OrientedBoundingBox\n\nDuplicates a OrientedBoundingBox instance.\n\n- `box` The bounding box to duplicate.\n- `result` The object onto which to store the result.\n  @returns {OrientedBoundingBox} A new OrientedBoundingBox instance.\n\n### equals(left, right) : Boolean\n\nCompares the provided OrientedBoundingBox componentwise and returns `true` if they are equal, `false` otherwise.\n\n- left The first\n- right The second\n\nreturns `true` if left and right are equal, `false` otherwise.\n\n### intersectPlane(plane : Plane) : Intersect\n\nDetermines which side of a plane the oriented bounding box is located.\n\n- `box` The oriented bounding box to test.\n- {Plane} plane The plane to test against.\n\nReturns\n- `Intersect.INSIDE` if the entire box is on the side of the plane the normal is pointing\n- `Intersect.OUTSIDE` if the entire box is on the opposite side, and\n- `Intersect.INTERSECTING` if the box intersects the plane.\n\n### distanceTo(point : Number[3]) : Number\n\nComputes the estimated distance from the closest point on a bounding box to a point.\n\n- `point` The point\n\nReturns\n\n- The estimated distance from the bounding sphere to the point.\n\n### distanceSquaredTo(point : Number[3]) : Number\n\nComputes the estimated distance squared from the closest point on a bounding box to a point.\n\n- `point` The point\n\nReturns\n\n- {Number} The estimated distance squared from the bounding sphere to the point.\n\n### computePlaneDistances(position : Number[3], direction : Number[3] [, result : Number[2]]) : Number[2]\n\nThe distances calculated by the vector from the center of the bounding box to position projected onto direction.\n\nIf you imagine the infinite number of planes with normal direction, this computes the smallest distance to the closest and farthest planes from position that intersect the bounding box.\n\n- `position` The position to calculate the distance from.\n- `direction` The direction from position.\n- `result` An optional Interval to store the nearest and farthest distances.\n\nReturns\n\n- The nearest and farthest distances on the bounding box from position in direction.\n\n### intersectPlane(plane : Plane) : Intersect\n\nDetermines which side of a plane the oriented bounding box is located.\n\n- `plane` The plane to test against.\n\nReturns\n\n- `Intersect.INSIDE` if the entire box is on the side of the plane the normal is pointing\n- `Intersect.OUTSIDE` if the entire box is on the opposite side, and\n- `Intersect.INTERSECTING` if the box intersects the plane.\n\n### getModelMatrix() : Matrix4\n\n```js\nconst modelMatrix = Matrix4.fromRotationTranslation(this.boundingVolume.halfAxes, this.boundingVolume.center);\n```\n\n## Attribution\n\nThis class was ported from [Cesium](https://github.com/AnalyticalGraphicsInc/cesium) under the Apache 2 License.\n","slug":"modules/culling/docs/api-reference/oriented-bounding-box","title":"OrientedBoundingBox"},{"excerpt":"Plane A plane in Hessian Normal Form defined by  where  is the plane's ,  is the signed distance to the plane (from the origin along the…","rawMarkdownBody":"# Plane\n\nA plane in Hessian Normal Form defined by `ax + by + cz + d = 0` where `[a, b, c]` is the plane's `normal`, `d` is the signed distance to the plane (from the origin along the normal), and `[x, y, z]` is any point on the plane.\n\n## Usage\n\n\nCreate the plane `x=0`\n```js\nimport {Plane} from '@math.gl/culling';\nconst plane = new Plane([1, 0, 0], 0.0);\n```\n\nCreate a tangent plane for a cartographic coordinate\n```js\nimport {Plane} from '@math.gl/culling';\nimport {Ellipsoid} from '@math.gl/geospatial';\nconst point = [-72.0, 40.0, 0];\nconst normal = Ellipsoid.WGS84.geodeticSurfaceNormal([-72.0, 40.0]);\nconst tangentPlane = new Plane().fromPointNormal(point, normal);\n```\n\n## Fields\n\n#### normal : Vector3\n\nThe plane's normal.\n\n#### distance : Number\n\nThe shortest distance from the origin to the plane. The sign of `distance` determines which side of the plane the origin is on. If `distance` is positive, the origin is in the half-space in the direction of the normal; if negative, the origin is in the half-space opposite to the normal; if zero, the plane passes through the origin.\n\n## Methods\n\n#### constructor(normal : Number[3], distance : Number)\n\n- `Vector3` normal The plane's normal (normalized).\n- Number distance The shortest distance from the origin to the plane. The sign of `distance` determines which side of the plane the origin is on. If `distance` is positive, the origin is in the half-space in the direction of the normal; if negative, the origin is in the half-space opposite to the normal; if zero, the plane passes through the origin.\n\nThrows\n- Normal must be normalized\n\n\n#### fromPointNormal(point : Number[3], normal : Number[3]) : Plane\n\nCreates a plane from a normal and a point on the plane.\n\n- `Vector3` point The point on the plane.\n- `Vector3` normal The plane's normal (normalized).\n- Plane [result] The object onto which to store the result.\n\nThrows\n- Normal must be normalized\n\n#### Plane.fromCoefficients(coefficients : Number[4]) : Plane\n\nCreates a plane from the general equation\n\n- `coefficients` The plane coefficients (normalized).\n\nThrows\n- Normal must be normalized\n\n#### clone() : Plane\n\nDuplicates a Plane instance.\n\nReturns\n- A new Plane instance with the same values\n\n#### equals(right : Plane) : Boolean\n\nCompares the provided Planes by normal and distance and returns `true` if they are equal, `false` otherwise.\n\n- `right` The second plane.\n\nReturns\n- `true` if left and right are equal, `false` otherwise.\n\n#### getPointDistance(point : Number[3]) : Number\n\nComputes the signed shortest distance of a point to a plane. The sign of the distance determines which side of the plane the point is on. If the distance is positive, the point is in the half-space in the direction of the normal; if negative, the point is in the half-space opposite to the normal; if zero, the plane passes through the point.\n\n- `point` The point.\n\nReturns\n- Number The signed shortest distance of the point to the plane.\n\n#### projectPointOntoPlane(point : Number[3] [, result : Number[3]]) : Number[3]\n\nProjects a point onto the plane.\n- `point` The point to project onto the plane\n- `result` The result point. If undefined, a new `Array` will be created.\n\nReturns\n- The modified result parameter or a new `Vector3` instance if one was not provided.\n\n#### transform(transform : Number[16]) : Plane\n\nTransforms the plane by the given transformation matrix.\n\n- Matrix4 transform The transformation matrix.\n- Plane [result] The object into which to store the result.\n\nReturns\n- Plane The plane transformed by the given transformation matrix.\n\n## Attribution\n\nThis class was ported from [Cesium](https://github.com/AnalyticalGraphicsInc/cesium) under the Apache 2 License.\n","slug":"modules/culling/docs/api-reference/plane","title":"Plane"},{"excerpt":"CullingVolume A culling volume defined by planes. Static Members CullingVolume.MASK_OUTSIDE For plane masks (as used in ), this special…","rawMarkdownBody":"# CullingVolume\n\nA culling volume defined by planes.\n\n## Static Members\n\n#### CullingVolume.MASK_OUTSIDE\n\nFor plane masks (as used in `CullingVolume#computeVisibilityWithPlaneMask`), this special value represents the case where the object bounding volume is entirely outside the culling volume.\n\n#### CullingVolume.MASK_INSIDE\n\nFor plane masks (as used in `CullingVolume.computeVisibilityWithPlaneMask`), this value represents the case where the object bounding volume is entirely inside the culling volume.\n\n#### CullingVolume.MASK_INDETERMINATE\n\nFor plane masks (as used in`CullingVolume.computeVisibilityWithPlaneMask`), this value represents the case where the object bounding volume (may) intersect all planes of the culling volume.\n\n## Methods\n\n#### constructor([planes : Plane[]])\n\n- `planes`=`[]` An array of clipping planes.\n\nEach plane is represented by a Cartesian4 object, where the x, y, and z components define the unit vector normal to the plane, and the w component is the distance of the plane from the origin.\n\n#### fromBoundingSphere(boundingSphere : BoundingSphere)\n\nConstructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere. The planes are aligned to the x, y, and z axes in world coordinates.\n\n- `boundingSphere` The bounding sphere used to create the culling volume.\n\n### computeVisibility(boundingVolume : Object) : Interset\n\nDetermines whether a bounding volume intersects the culling volume.\n\n- `boundingVolume` The bounding volume whose intersection with the culling volume is to be tested.\n\nReturns\n- `Intersect.OUTSIDE`, `Intersect.INTERSECTING`, or `Intersect.INSIDE`.\n\n### computeVisibilityWithPlaneMask(boundingVolume : Object, parentPlaneMask : Number) : Number\n\nDetermines whether a bounding volume intersects the culling volume.\n\n- `boundingVolume` The bounding volume whose intersection with the culling volume is to be tested.\n- `parentPlaneMask` A bit mask from the boundingVolume's parent's check against the same culling volume, such that if `planeMask & (1 << planeIndex) === 0`, for `k < 31`, then the parent (and therefore this) volume is completely inside `plane[planeIndex]` and that plane check can be skipped.\n\nReturns\n- A plane mask as described above (which can be applied to this boundingVolume's children).\n\n## Attribution\n\nThis class was ported from [Cesium](https://github.com/AnalyticalGraphicsInc/cesium) under the Apache 2 License.\n","slug":"modules/culling/docs/api-reference/culling-volume","title":"CullingVolume"},{"excerpt":"Culling Overview The  module provides primitives for implementing frustum culling. It does provides fully \"transformable\" primitives (i.e…","rawMarkdownBody":"# Culling Overview\n\nThe `@math.gl/culling` module provides primitives for implementing frustum culling.\n\n- It does provides fully \"transformable\" primitives (i.e. oriented bounding boxes as opposed to just axis-aligned bounding boxes).\n- It does not attempt to be a general collision detection library (i.e. does not handle time-interpolated intersections).\n\n## Classes\n\n| Class                 | Description |\n| ---                   | --- |\n| `CullingVolume`       | |\n| `BoundingSphere`      | |\n| `OrientedBoundingBox` | |\n| `Plane`               | |\n\n## Example Usage\n\n- Create bounding volumes for your objects/geometries, and create `BoundingSphere` or `OrientedBoundingBox` instances.\n- Extract your camera view frustum parameters and create a `PerspectiveFrustum` instance.\n- You can now test your bounding volumes to see if the intersect the view frustum.\n\n\n## Framework Independence\n\nLike all non-core math.gl modules, this library can be used without the math.gl core classes.\n\n- Any input vectors can be supplied as length 3 JavaScript `Array` instances.\n- Any result vectors can be treated as length 3 JavaScript `Array` instances (they may be math.gl `Vector3`).\n- The core math.gl classes inherit from JavaScript `Array` and can be used directly as input.\n\n## History\n\nThis library was initially developed as a fork of the Cesium math library as part of a collaboration between Cesium and Uber to provide framework-independent, portable support for the 3D tiles specification.\n\n## Attribution\n\nThis code in was initially forked from [Cesium](https://github.com/AnalyticalGraphicsInc/cesium) under the Apache 2 License.\n","slug":"modules/culling/docs/developer-guide/culling-guide","title":"Culling Overview"},{"excerpt":"Helpers Helper functions for geospatial. Usage Check if a given coordinate is close to the surface of the earth on the earth ellipsoid.","rawMarkdownBody":"# Helpers\n\nHelper functions for geospatial.\n\n## Usage\n\nCheck if a given coordinate is close to the surface of the earth on the earth ellipsoid.\n```js\nimport {isWGS84} from '@math.gl/geospatial';\nisWGS84([17832.12, 83234.52, 952313.73]);\n```\n","slug":"modules/geospatial/docs/api-reference/helpers","title":"Helpers"},{"excerpt":"Ellipsoid A quadratic surface defined in Cartesian coordinates by the equation . Primarily used to represent the shape of planetary bodies…","rawMarkdownBody":"# Ellipsoid\n\nA quadratic surface defined in Cartesian coordinates by the equation `(x / a)^2 + (y / b)^2 + (z / c)^2 = 1`. Primarily used to represent the shape of planetary bodies.\n\nThe main use of this class is to convert between the \"cartesian\" and \"cartographic\" coordinate systems.\n\nRather than constructing this object directly, one of the provided constants is used.\n\n## Usage\n\nDetermine the Cartesian representation of a Cartographic position on a WGS84 ellipsoid.\n```js\nimport {toRadians} from 'math.gl';\nimport {Ellipsoid} from '@math.gl/geospatial';\nconst cartographicPosition = [toRadians(21), toRadians(78), 5000];\nconst cartesianPosition = Ellipsoid.WGS84.cartographicToCartesian(cartographicPosition);\n```\n\nDetermine the Cartographic representation of a Cartesian position on a WGS84 ellipsoid.\n```js\nimport {Ellipsoid} from '@math.gl/geospatial';\nconst cartesianPosition = [17832.12, 83234.52, 952313.73];\nconst cartographicPosition = Ellipsoid.WGS84.cartesianToCartographic(cartesianPosition);\n```\n\nGet the transform from local east-north-up at cartographic (0.0, 0.0) to Earth's fixed frame.\n```js\nimport {Ellipsoid} from '@math.gl/geospatial';\nconst transformMatrix = Ellipsoid.WGS84.eastNorthUpToFixedFrame([0, 0, 0]);\n```\n\n## Static Fields\n\n#### Ellipsoid.WGS84 : Ellipsoid (readonly)\n\nAn Ellipsoid instance initialized to the WGS84 standard.\n\n## Members\n\n#### radii : Vector3 (readonly)\n\nGets the radii of the ellipsoid.\n\n#### radiiSquared : Vector3 (readonly)\n\nGets the squared radii of the ellipsoid.\n\n#### radiiToTheFourth : Vector3 (readonly)\n\nGets the radii of the ellipsoid raise to the fourth power.\n\n#### oneOverRadii : Vector3 (readonly)\n\nGets one over the radii of the ellipsoid.\n\n#### oneOverRadiiSquared : Vector3 (readonly)\n\nGets one over the squared radii of the ellipsoid.\n\n#### minimumRadius : Number (readonly)\n\nGets the minimum radius of the ellipsoid.\n\n#### maximumRadius : Number\n\nGets the maximum radius of the ellipsoid.\n\n## Methods\n\n#### constructor(x : Number, y : Number, z : Number)\n\n- `x`=`0` The radius in the x direction.\n- `y`=`0` The radius in the y direction.\n- `z`=`0` The radius in the z direction.\n\nThrows\n\n- All radii components must be greater than or equal to zero.\n\n#### clone() : Ellipsoid\n\nDuplicates an Ellipsoid instance.\n\n- {Ellipsoid} [result] Optional object onto which to store the result, or undefined if a new\n  instance should be created.\n\nReturns\n- The cloned `Ellipsoid`.\n\n#### equals(right : Ellipsoid) : Boolean\n\nCompares this Ellipsoid against the provided Ellipsoid componentwise.\n\n- `right` The other Ellipsoid. used.\n\nReturns\n- `true` if they are equal, `false` otherwise.\n\n#### toString() : String\n\nCreates a string representing this Ellipsoid in the format used `'[radii.x, radii.y, radii.z]`.\n\nReturns\n\n- A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n\n#### cartographicToCartesian(cartographic : Number[3] [, result : Number[3]]) : Vector3 | Number[3]\n\nConverts the provided cartographic to Cartesian representation.\n\n- `cartographic` The cartographic position.\n- `result` Optional object onto which to store the result.\n\nReturns\n\n- The modified `result` parameter or a new `Vector3` instance if none was provided.\n\n#### cartesianToCartographic(cartesian : Number[3] [, result : Number[3]]) : Vector3 | Number[3] | `undefined`\n\nConverts the provided cartesian to cartographic representation. The cartesian is `undefined` at the center of the ellipsoid.\n\n- `cartesian` The Cartesian position to convert to cartographic representation.\n- `result` Optional object onto which to store the result.\n\nReturns\n\n- The modified result parameter, new `Vector3` instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.\n\n\n#### eastNorthUpToFixedFrame(origin : Number[3], ellpsoid : Ellipsoid, result : Number[16]) : Matrix4 | Number[16]\n\nComputes a 4x4 transformation matrix from a reference frame with an east-north-up axes centered at the provided origin to the provided ellipsoid's fixed reference frame.\n\nThe local axes are defined as:\n- The `x` axis points in the local east direction.\n- The `y` axis points in the local north direction.\n- The `z` axis points in the direction of the ellipsoid surface normal which passes through the position.\n\n- `origin` The center point of the local reference frame.\n- `ellipsoid`=`Ellipsoid.WGS84` The ellipsoid whose fixed frame is used in the transformation.\n- `result` Optional object onto which to store the result.\n\nReturns\n\n- The modified `result` parameter or a new `Matrix4` instance if none was provided.\n\nNotes\n\n- Calls `localFrameToFixedFrame` with `east`, `north`, `up` axis.\n\n#### localFrameToFixedFrame(String firstAxis, secondAxis : String, thirdAxis : String | null, origin : Number[3] \\[, result : Number[16]]) : Matrix4 | Number[16]\n\nComputes a 4x4 transformation matrix from a reference frame centered at the provided origin to the ellipsoid's fixed reference frame.\n\n- `firstAxis`  name of the first axis of the local reference frame. Must be 'east', 'north', 'up', 'west', 'south' or 'down'.\n- `secondAxis`  name of the second axis of the local reference frame.\n- `thirdAxis`  name of the third axis of the local reference frame. Can be omitted as it is implied by the cross product of the first two axis.\n- `origin` The center point of the local reference frame.\n- `result` Optional object onto which to store the result.\n\nReturns\n\n- A 4x4 transformation matrix from a reference frame, with first axis and second axis compliant with the parameters, in the modified `result` parameter or a new `Matrix4` instance if none was provided.\n\n#### geocentricSurfaceNormal(cartesian : Number[3] [, result : Number[3]]) : Vector3 | Number[3]\n\nComputes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.\n\n- `cartesian` - The WSG84 cartesian coordinate for which to to determine the geocentric normal.\n- `result` - Optional object onto which to store the result.\n\nReturns\n\n- The modified result parameter or a new `Vector3` instance if none was provided.\n\n#### geodeticSurfaceNormalCartographic(cartographic : Number[3] [, result : Number[3]]) : Vector3 | Number[3]\n\nComputes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n\n- `cartographic` The cartographic position for which to to determine the geodetic normal.\n- `result` Optional object onto which to store the result.\n\nReturns\n\nThe modified result parameter or a new `Vector3` instance if none was provided.\n\n#### geodeticSurfaceNormal(cartesian : Number[3] [, result : Number[3]]) : Vector3 | Number[3]\n\nComputes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n\n- `cartesian` The Cartesian position for which to to determine the surface normal.\n- `result` Optional object onto which to store the result.\n\nReturns\n\n- The modified `result` parameter or a new `Vector3` instance if none was provided.\n\n#### scaleToGeodeticSurface(cartesian : Number[3] [, result : Number[3]]) : Vector3 | Number[3] | `undefined`\n\nScales the provided Cartesian position along the geodetic surface normal so that it is on the surface of this ellipsoid. If the position is at the center of the ellipsoid, this function returns `undefined`.\n\n- `cartesian` The Cartesian position to scale.\n- `result` Optional object onto which to store the result.\n\nReturns\n\n- The modified result parameter, a new `Vector3` instance if none was provided, or undefined if the position is at the center.\n\n#### scaleToGeocentricSurface(cartesian : Number[3] [, result : Number[3]]) : Vector3 | Number[3]\n\nScales the provided Cartesian position along the geocentric surface normal so that it is on the surface of this ellipsoid.\n\n- `cartesian` The Cartesian position to scale.\n- `result` Optional object onto which to store the result.\n\nReturns\n- The modified `result` parameter or a new `Vector3` instance if none was provided.\n\n#### transformPositionToScaledSpace(position : Number[3] [, result : Number[3]]) : Vector3 | Number[3]\n\nTransforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying its components by the result of `Ellipsoid.oneOverRadii`.\n\n- `position` The position to transform.\n- `result` Optional array into which to copy the result.\n\nReturns\n\n- The position expressed in the scaled space. The returned instance is the one passed as the `result` parameter if it is not undefined, or a new instance of it is.\n\n#### transformPositionFromScaledSpace(position : Number[3] [, result : Number[3]]) : Vector3 | Number[3]\n\nTransforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying its components by the result of `Ellipsoid.radii`.\n\n- `position` The position to transform.\n- `result` Optional array to which to copy the result.\n\nReturns\n\n- The position expressed in the unscaled space. The returned array is the one passed as the `result` parameter, or a new `Vector3` instance.\n\n#### getSurfaceNormalIntersectionWithZAxis(position, buffer, result) : | undefined\n\nComputes a point which is the intersection of the surface normal with the z-axis.\n\n- `position` the position. must be on the surface of the ellipsoid.\n- `buffer`=`0.0` A buffer to subtract from the ellipsoid size when checking if the point is inside the ellipsoid.\n- `result` Optional array into which to copy the result.\n\nReturns\n\n- The intersection point if it's inside the ellipsoid, `undefined` otherwise.\n\nThrows\n\n- `position` is required.\n- `Ellipsoid` must be an ellipsoid of revolution (`radii.x == radii.y`).\n- Ellipsoid.radii.z must be greater than 0.\n\nNotes:\n\n- In earth case, with common earth datums, there is no need for this buffer since the intersection point is always (relatively) very close to the center.\n- In WGS84 datum, intersection point is at max z = +-42841.31151331382 (0.673% of z-axis).\n- Intersection point could be outside the ellipsoid if the ratio of MajorAxis / AxisOfRotation is bigger than the square root of 2\n\n## Attribution\n\nThis class was ported from [Cesium](https://github.com/AnalyticalGraphicsInc/cesium) under the Apache 2 License.\n","slug":"modules/geospatial/docs/api-reference/ellipsoid","title":"Ellipsoid"},{"excerpt":"Geospatial Math Overview The  librarys provides support for geospatial math. It provides classes and utilities to facilitate working with…","rawMarkdownBody":"# Geospatial Math Overview\n\nThe `@math.gl/geospatial` librarys provides support for geospatial math.\n\nIt provides classes and utilities to facilitate working with the major geospatial coordinate systems and projections used with computer maps, primarily:\n\n- [WGS84](https://en.wikipedia.org/wiki/World_Geodetic_System) (World Geodetic System) coordinates.\n- [Web Mercator Projection](https://en.wikipedia.org/wiki/Web_Mercator_projection)\n\n\n## Ellipsoid and WGS84\n\n| Class                   | Dewscription |\n| ---                     | --- |\n| `Ellipsoid`             | Implements ellipsoid |\n| `Ellipsoid.WSG84`       | An `Ellipsoid` instance initialized with Earth radii per WGS84. |\n\n## Usage Examples\n\nA major use of this library is to convert between \"cartesian\" (`x`, `y`, `z`) and \"cartographic\" (`longitude`, `latitude`, `height`) representations of WSG84 coordinates. The `Ellipsoid` class implements these calculations.\n\n## Usage\n\nDetermine the Cartesian representation of a Cartographic position on a WGS84 ellipsoid.\n```js\nimport {toRadians} from 'math.gl';\nimport {Ellipsoid} from '@math.gl/geospatial';\nconst cartographicPosition = [toRadians(21), toRadians(78), 5000];\nconst cartesianPosition = Ellipsoid.WGS84.cartographicToCartesian(cartographicPosition);\n```\n\nDetermine the Cartographic representation of a Cartesian position on a WGS84 ellipsoid.\n```js\nimport {Ellipsoid} from '@math.gl/geospatial';\nconst cartesianPosition = [17832.12, 83234.52, 952313.73];\nconst cartographicPosition = Ellipsoid.WGS84.cartesianToCartographic(cartesianPosition);\n```\n\nGet the transform from local east-north-up at cartographic (0.0, 0.0) to Earth's fixed frame.\n```js\nimport {Ellipsoid} from '@math.gl/geospatial';\nconst transformMatrix = Ellipsoid.WGS84.eastNorthUpToFixedFrame([0, 0, 0]);\n```\n\n## Framework Independence\n\nLike all non-core math.gl modules, this module can be used independently of core math.gl classes.\n\n- Any input or result vectors can be supplied as JavaScript `Array` instances of length 3, or objects with `x`, `y`, `z` elements.\n\n\n## History\n\nThis library was initially developed as a fork of selected classes from Cesium math library, as part of a collaboration between vis.gl and Cesium teams to provide framework-independent, portable support for the 3D tiles specification.\n\n## Attribution\n\nThis code was initially forked from [Cesium](https://github.com/AnalyticalGraphicsInc/cesium) under the Apache 2 License.\n\n","slug":"modules/geospatial/docs/developer-guide/geospatial-guide","title":"Geospatial Math Overview"},{"excerpt":"@math.gl/culling @math.gl/culling is a suite of math modules for 3D applications. This module contains classes for vectors and matrices etc…","rawMarkdownBody":"# @math.gl/culling\n\n[@math.gl/culling](https://math.gl/docs) is a suite of math modules for 3D applications.\n\nThis module contains classes for vectors and matrices etc.\n\nFor documentation please visit the [website](https://math.gl).\n","slug":"modules/culling","title":"@math.gl/culling"},{"excerpt":"Features (WIP) This document is Work-In-Progress. See features for more details. Array-based This allows you to keep your API functions…","rawMarkdownBody":"# Features (WIP)\n\n> This document is Work-In-Progress.\n\nSee [features](./doc/get-started/features.md) for more details.\n\n\n## Array-based\n    - All math objects can be used directly with any Javascript\n      function that expects array arguments. No need to call `toArray`\n      or similar.\n    - Math objects are `Arrays` - All math objects are subclasses of the built-in\n      JavaScript `Array` class, which means that class instances can be used\n      wherever an array is expected. I.e. these classes are not wrappers of\n      `Array`s, they **are** `Array`s, just with additional methods.\n\nThis allows you to keep your API functions general (the accept general arrays and so are not tied to a specific math library).\n\n- **Debugging**\n    - Optional error checking after every math operation makes quick work of locating coding errors and bad data.\n    - Printing support simplifies debugging\n    - Only minor performance impact, and can be disabled when performance is critical.\n\n- **WebGL-friendly**\n    - Column Major atrices: while all accessors, `toString()` etc are row-major.\n      matrices are organized internally in the layout expected\n      by WebGL (an array of contiguous floats in column-major order),\n    - `toArray` and `fromArray` functions take optional offsets allowing\n      copying directly to and from vertex attribute array.\n    - GLSL math functions (radians, sin etc) made available in JavaScript\n      and work both on scalars and vectors / math objects.\n\n- **Documentation**\n    - Most JavaScript 3D math libraries come with a reference documentation only. It can be a \n\n- **Size Conscious**\n    - A math library can quickly get big as a various , gl-matrix is a good example, there are a number of modules on npm that contain subsets of gl-matrix to work around its size.\n    - Focus on functions that are likely to be most important in WebGL applications.\n\n\n## Supported Browsers\n\nSome background:\n* math.gl classes are subclasses of the built-in JavaScript `Array`. `Array` subclassing is an ES6/JS2015 feature. This feature (even after being transpiled to ES5) does not work with older browsers.\n* For details of the technical complication, see ([babel-plugin-transform-builtin-extend](https://github.com/loganfsmyth/babel-plugin-transform-builtin-extend)).\n\n\n\n## Overview\n\nmath.gl is a JavaScript math library primarily intended to support WebGL applications. It is a generic library but was developed as a companion for [luma.gl](http://uber.github.io/luma.gl/) and [deck.gl](http://uber.github.io/deck.gl/).\n\nmath.gl contains a set of classes (Matrix4 etc) to complement the procedural interface of gl-matrix. It also imports a limited subset of the standard `gl-matrix` functions (to keep bundle size down), these can be used in parallel with the classes.\n\n\n## Who is this for?\n\nJavaScript WebGL programmers who:\n* Need a great JavaScript math library for basic computional geometry purposes.\n* like the functionality offered by the gl-matrix library\n* need tree-shaking support\n* want to use object orientated math programming style (ability to chain operations).\n* want optional extra error checking\n* do not need to support old (pre-IE10) browsers.\n\n\n## Features\n\n- **Array-based**\n    - All math objects can be used directly with any Javascript function that expects array arguments. No need to call `toArray` or similar.\n\n- **Error checking** to assist in debugging.\n    - Can be disabled when performance is critical.\n\n- **WebGL-friendly**\n    - Matrices: while all accessors, `toString()` etc are row-major. Matrices are organized internally in the layout expected by WebGL (an array of contiguous floats in column-major order),\n    - `toArray` and `fromArray` functions take optional offsets allowing copying directly to and from vertex attribute arrays.\n    - GLSL math functions (radians, sin etc) made available in JavaScript and work both on scalars and vectors / math objects.\n\n\n# Design Notes\n\n- Math objects are `Arrays` - All math objects are subclasses of the built-in JavaScript `Array` class, which means that class instances can be used wherever an array is expected. I.e. these classes are not wrappers of `Array`s, they **are** `Array`s, just with additional methods.\n\n- Focuses on needs of WebGL based applications and basic computational geometry, which includes 4x4 matrices, 2, 3 and 4 dimensional vectors and quaternions. May grow to include other classes, but is not intended to become a general math library.\n\n\n# History\n\n- Started out as a set of object oriented wrappers for the procedural [gl-matrix](http://glmatrix.net/) library.\n\n\n# Roadmap\n\n- Additional classes and functions. This library might grow beyond just providing `gl-matrix` wrappers if additional classes are deemed valuable for the target user group.\n\n\n## API differences with gl-matrix\n\nThe class API is intentionally designed to remain intuitively similar to the wrapped `gl-matrix` procedures, usually just removing the first one or two parameters from each function (the out argument and the first input arguments, both are implictly set to this), and exposes the remaining arguments in the same order as the gl-matrix api.\n\nOnly in a few cases where `gl-matrix` methods take a long list arguments (e.g. `mat4.perspective`, `mat4.ortho` etc) or return multiple values (e.g. `quat.getAxisRotation`) do methods provide a modified API that is more natural for modern ES6 applications to use, e.g. using named parameters, or collecting all results in one returned object.\n\nAlso, for transforming vectors with matrices, the `transform*` methods are offered in the matrix classes, instead of on the vector classes. They also (optionally) auto allocate the result vectors.\n\n\n## Caveats\n\nA technical caveat is that JavaScript `Array` subclassing, which is fundamental to the design of this library, is only supported on \"evergreen\" browsers, such as Chrome, Safari, Firefox, Edge etc, i.e. no Internet Explorer < 10 ([details](https://github.com/loganfsmyth/babel-plugin-transform-builtin-extend)).\n\nIf this is not acceptable, math.gl is not the right choice for you. As a fallback, you can always use `gl-matrix` directly.\n\n","slug":"modules/core/docs/wip/features","title":"Features (WIP)"},{"excerpt":"About the Vector Classes (WIP) This document is Work-In-Progress. Two, three and four dimensional vector classes Vector2, Vector3, Vector…","rawMarkdownBody":"# About the Vector Classes (WIP)\n\n> This document is Work-In-Progress.\n\nTwo, three and four dimensional vector classes\n\n## Vector2, Vector3, Vector4 Methods\n\n| **Method** | **Description** |\n| --- | --- |\n| `constructor` | Creates a Vector |\n| `ELEMENTS` | Get the dimensionality of the vector |\n| `x` | Set/get x component |\n| `y` | Set/get y component |\n| `z` | Set/get z component (`Vector3` and `Vector4` only) |\n| `w` | Set/get w component (`Vector4` only) |\n| `set` | Set values |\n| `add` | Vectors addition |\n| `subtract` | Vectors subtraction |\n| `multiply` | Vectors multiplication |\n| `divide` | Vectors division |\n| `scale` | Scales a Vector by a scalar number |\n| `scaleAndAdd` | Adds two vectors after scaling the second operand by a scalar value |\n| `negate` | Negate a vector |\n| `inverse` | Inverse a vector (`Vector3` and `Vector4` only |\n| `normalize` | Normalize a vector |\n| `dot` | Dot product of two vectors |\n| `cross` | Cross product of two vectors (`Vector3` only) |\n| `lerp` | Linear interpolation between two Vector |\n| `operation` | Apply general operations on all vectors |\n\n\n","slug":"modules/core/docs/wip/using-vectors","title":"About the Vector Classes (WIP)"},{"excerpt":"Matrix  is a base class for  and , providing common methods to those classes. Methods toString() Returns a string representation of the…","rawMarkdownBody":"# Matrix\n\n`Matrix` is a base class for [`Matrix3`](./docs/api-reference/vector3) and [`Matrix4`](./docs/api-reference/vector4), providing common methods to those classes.\n\n## Methods\n\n#### toString()\n\nReturns a string representation of the matrix\n\n#### setElement\n\nSets the element at \"conceptual position\" `M[i][j]`, row major indices by default\n\n`matrix3.set(i, j, value, columnMajor = false)`\n\n\n#### getElement\n\nGets the element at \"conceptual position\" `M[i][j]`, row major indices by default\n\n`matrix3.get(i, j, columnMajor = false)`\n\n#### getColumn(columnIndex : Number [ , result : Number[3]]) : Number[3]\n\nExtracts a column from the matrix\n\n#### setColumn(columnIndex : Number, columnVector : Number[3]) : Matrix\n\nCopies a column into the matrix\n","slug":"modules/core/docs/api-reference/matrix","title":"Matrix"},{"excerpt":"Matrix3 A 3x3 matrix. Any arguments can be plain JavaScript arrays or other  objects. Usage Copy a matrix to a  so that it can be…","rawMarkdownBody":"# Matrix3\n\nA 3x3 matrix. Any arguments can be plain JavaScript arrays or other `math.gl` objects.\n\n## Usage\n\n```js\nimport {Matrix3} from `math.gl`;\n```\n\nCopy a matrix to a `Matrix3` so that it can be manipulated (and mutated) with `Matrix3` methods:\n```js\nconst IDENTITY = [1, 0, ..., 1];\nconst m = new Matrix3(IDENTITY).translate([1, 0]);\n```\n\nInvert a matrix\n```js\nconst inverse = matrix.invert();\n```\n\nTransform a vector as a point (including translations)\n```js\nconst transform = new Matrix3();\nconst vector2 = transform.transformPoint([1, 2]);\nconst vector3 = transform.transformPoint([1, 2, 1]);\n```\n\nTransform a vector as a direction (NOT including translations)\n```js\nconst transform = new Matrix3();\nconst vector2 = transform.transformDirection([1, 2]);\nconst vector3 = transform.transformDirection([1, 2, 1]);\n```\n\n## Inheritance\n\n`class Matrix3 extends [Matrix](./docs/api-reference/matrix) extends [MathArray](./docs/api-reference/math-array) extends [Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)`\n\n## Methods\n\nMany of the most commonly used methods are inherited from [`MathArray`](./docs/api-reference/math-array.md):\n\n* `matrix3.clone()`\n* `matrix3.copy(array)`\n* `matrix3.set(...args)`\n* `matrix3.fromArray(array, offset = 0)`\n* `matrix3.toString()`\n* `matrix3.toArray(array = [], offset = 0)`\n* `matrix3.equals(array)`\n* `matrix3.exactEquals(array)`\n* `matrix3.validate(array = this)`\n* `matrix3.check(array = this)`\n* `matrix3.normalize()`\n\nNote that `Matrix3` is a subclass of the built in JavaScript `Array` and can thus e.g. be supplied as a parameter to any function expecting an `Array`.\n\n\n### constructor\n\nCreates an empty `Matrix3`\n\n`new Matrix3()`\n\n\n### identity\n\nSets the matrix to the multiplicative identity matrix.\n\n`matrix3.identity()`\n\n\n### set\n\nSets the elements of the matrix.\n\n`matrix3.set(m00, m01, m02, m10, m11, m12, m20, m21, m22)`\n\n\n### fromQuaternion\n\nSets the matrix to a transformation corresponding to the rotations represented by the given quaternion.\n\n`matrix3.fromQuaternion(quaternion)`\n\n* `quaternion` (`Quaternion`) - the quaternion  to create matrix from\n\n\n### determinant()\n\nReturns the determinant of the matrix (does not modify the matrix).\n\n`const determinant = matrix3.determinant()`\n\nReturns (`Number`) - the determinant\n\n* If the determinant is zero, the matrix is not invertible.\n* Determinant calculation is somewhat expensive.\n\n\n### transpose\n\nSets this matrix to its transpose matrix.\n\n`matrix3.transpose()`\n\n* The transpose matrix mirrors the original matrix elements in the diagonal.\n\n\n### invert\n\nSets this matrix to its inverse matrix.\n\n`matrix3.invert()`\n\n* The inverse matrix times its original matrix is an identity matrix of the same size.\n\n\n### multiplyLeft\n\nMultiplies in another matrix from the left\n\n`matrix3.multiplyLeft(matrix3)`\n\n* When using `Matrix3` to transform vectors, the vectors are multiplied in from the right. This means that the multiplying in a matrix from the left will cause it to be applied last during transformation (unless additional matrices are multiplied in from the left of course).\n\n\n### multiplyRight\n\n`matrix3.multiplyRight(matrix3)`\n\n* When using `Matrix3` to transform vectors, the vectors are multiplied in from the right. This means that the multiplying in a matrix from the left will cause it to be applied last during transformation (unless additional matrices are multiplied in from the left of course).\n\n### rotate\n\nAdds a rotation by the given angle. Equivalent to right multiplying the new transform into the matrix but more performant.\n\n`matrix3.rotate(radians)`\n\n### scale\n\nAdds a scaling transform, each axis can be scaled independently.\n\n`matrix3.scale(factor)`\n* `factor` (Number) - scale factor to be applied to each axis.\n\n`matrix3.scale([x, y])`\n* `x` (Number) - scale factor to be multiplied into x component\n* `y` (Number) - scale factor to be multiplied into y component\n\nEquivalent to right multiplying the new transform into the matrix but more performant.\n\n* During vector transformation all coordinates will be multiplied with the given factors.\n* Scale with `-1` will flip the coordinate system in that axis.\n* Scale with `0` will drop that component.\n\n\n### translate\n\nAdds a translation to the matrix.\n\n`matrix3.translate([x, y])`\n* `x` (Number) - translation to be added to the x component\n* `y` (Number) - translation to be added to the y component\n\nEquivalent to right multiplying the new transform into the matrix but more performant.\n\nDuring vector transformation the given translation values are added to each component of the vector being transformed.\n\n\n### transformVector\n\n`transformVector(vector, out)`\n\n* `vector` (`Array`|`Vector2`|`Vector3`)\n* `out` - unless supplied, will be a `Vector2` or `Vector3`, matching the length of input vector.\nReturns `out`, or a newly minted `Vector2` or `Vector3`.\n\n\n\n## Remarks\n\n* All transforms are effectively \"right multiplied\" onto the matrix (meaning that during transform they will be applied in opposite order).\n* `Matrix3` is stored internally in column major format (per WebGL conventions). This only matters when you read out the matrix to use it with other software.\n","slug":"modules/core/docs/api-reference/matrix3","title":"Matrix3"},{"excerpt":"MathArray Usage  is a base class, and should not be instantiated directly. Cloning an object Scaling with constants Scaling with vectors is…","rawMarkdownBody":"# MathArray\n\n```js\nclass MathArray extends Array\n```\n\n## Usage\n\n`MathArray` is a base class, and should not be instantiated directly.\n\nCloning an object\n```js\nconst clone = vector.clone();\n```\n\n\nScaling with constants\n```js\nconst u = v.scale(-1); // Reverse direction vector\n```\n\nScaling with vectors is very flexible, you can e.g. set a component to zero, or flip a component's sign.\n```js\nconst u = v.scale([1, 1, 0]); // Set z component to zero\nconst w = v.scale([1, -1, 1]); // Flip y component\n```\n\n\n\n## Methods\n\n### clone\n\n`array.clone()`\n\n\n### copy\n\n`array.copy(array)`\n\n\n### set\n\n`array.set(...args)`\n\n\n### fromArray\n\n`array.fromArray(array, offset = 0)`\n\n\n### toString\n\nCalls `formatString` with the global math.gl config.\n\n`array.toString()`\n\n### formatString\n\n`array.formatString(config)`\n\n\n### toArray\n\n`array.toArray(array = [], offset = 0)`\n\n\n### toFloat32Array\n\n`array.toFloat32Array()`\n\n\n### equals\n\n`array.equals(array)`\n\n\n### exactEquals\n\n`array.exactEquals(array)`\n\n\n### length\n\n`array.length()`\n\n\n### lengthSquared\n\n`array.lengthSquared()`\n\n\n### distance\n\n`array.distance(mathArray)`\n\n\n### distanceSquared\n\n`array.distanceSquared(mathArray)`\n\n\n### normalize\n\n`array.normalize()`\n\n\n### validate\n\nChecks if a `MathArray` contains valid values.\n\n`array.validate(array = this)`\n\nReturns `false` if any value fails `Number.isFinite` test.\n\n\n### check\n\nIf `config.debug` is true, validates the `MathArray` and throws an error if it does not contains valid values.\n\n`array.check(array = this)`\n\nMote: This method is called by all mutating methods.\n","slug":"modules/core/docs/api-reference/math-array","title":"MathArray"},{"excerpt":"Pose (Experimental) Note this class is experimental and may change or be removed in minor math.gl versions. A 6-degree-freedom pose (3D…","rawMarkdownBody":"# Pose (Experimental)\n\n> Note this class is experimental and may change or be removed in minor math.gl versions.\n\nA 6-degree-freedom pose (3D position and 3D rotation).\nSee [Tait–Bryan angles](https://en.wikipedia.org/wiki/Euler_angles): z-y'-x\"\n\n```js\nclass Pose\n```\n\n## Usage\n\n```js\nimport {_Pose as Pose} from 'math.gl';\n```\n\n##  Members\n\n### x, y z\n\nGets or sets position components respectively\n\n### roll, pitch, yaw\n\nGets or sets rotation components respectively\n\n\n## Methods\n\n### constructor\n\n```\nnew Pose({x, y, z, roll, pitch, yaw});\nnew Pose({position, orientation});\n```\n\n * `x`, `y`, `z` - position\n * `roll`, `pitch`, `yaw` - rotation in radians\n * `position` - `Vector3` or array of 3 that represents the position\n * `orientation` - `Euler` or array of 4 that represents the rotation\n\n### getPosition\n\n`pose.getPosition()`\n\nReturns `Vector3`.\n\n### getOrientation\n\n`pose.getOrientation()`\n\nReturns `Euler`.\n\n### equals\n\n`pose.equals(otherPose)`\n\n### exactEquals\n\n`pose.exactEquals(otherPose)`\n\n### getTransformationMatrix\n\n`pose.getTransformationMatrix()`\n\nReturns a 4x4 matrix that transforms a coordinates (in the same\ncoordinate system as this pose) into the \"pose-relative\" coordinate\nsystem defined by this pose.\n\nThe pose relative coordinates with have origin in the position of this\npose, and axis will be aligned with the rotation of this pose.\n\nReturns `Matrix4`.\n\n### getTransformationMatrixFromPose\n\n`pose.getTransformationMatrixFromPose(otherPose)`\n\nGiven a second pose that represent the same object in a second coordinate\nsystem, this method returns a 4x4 matrix that transforms coordinates in the\nsecond coordinate system into the coordinate system of this pose.\n\nReturns `Matrix4`.\n\n### getTransformationMatrixToPose\n\n`pose.getTransformationMatrixToPose(otherPose)`\n\nGiven a second pose that represent the same object in a second coordinate\nsystem, this method returns a 4x4 matrix that transforms coordinates in the\ncoordinate system of this pose into the coordinate system of the second pose.\n\nReturns `Matrix4`.\n","slug":"modules/core/docs/api-reference/pose","title":"Pose (Experimental)"},{"excerpt":"Quaternion A class to handle Quaternions. More information on quternions can be found here. The quaternion will be represented by an…","rawMarkdownBody":"# Quaternion\n\n```js\nclass Quaternion extends MathArray extends Array\n```\n\nA class to handle Quaternions. More information on quternions can be found [here](http://en.wikipedia.org/wiki/Quaternion). The quaternion will be represented by an instance with `x`, `y`, `z`, `w` components that make a quaternion like: `xi + yj + zk + w`.\n\n## Usage\n\n```js\nimport {Quaternion} from 'math.gl';\n```\n\n## Members\n\n### x, y, z, w\n\nGets or sets element 0, 1, 2 or 3 respectively\n\n\n## Methods\n\nMany of the most commonly used methods are inherited from [`MathArray`](./docs/api-reference/math-array.md):\n\n* `quaternion.clone()`\n* `quaternion.copy(array)`\n* `quaternion.set(...args)`\n* `quaternion.fromArray(array, offset = 0)`\n* `quaternion.toString()`\n* `quaternion.toArray(array = [], offset = 0)`\n* `quaternion.equals(array)`\n* `quaternion.exactEquals(array)`\n* `quaternion.validate(array = this)`\n* `quaternion.check(array = this)`\n* `quaternion.normalize()`\n\nNote that `Quaternion` is a subclass of the built in JavaScript `Array` and can thus technically be supplied as a parameter to any function expecting an `Array`.\n\n\n### constructor\n\n`constructor(x = 0, y = 0, z = 0, w = 1)`\n\n\n### fromMatrix3\n\nCreates a quaternion from the given 3x3 rotation matrix. NOTE: The resultant quaternion is not normalized, so you should be sure to renormalize the quaternion yourself where necessary.\n\n`fromMatrix3(m)`\n\n\n### fromValues\n\nCreates a new quat initialized with the given values\n\n`fromValues(x, y, z, w)`\n\n\n### identity\n\nSet a quat to the identity quaternion\n\n`identity()`\n\n\n### length\n\nCalculates the length of a quaternion\n\n`length()`\n\n\n### squaredLength\n\nCalculates the squared length of a quaternion\n\n`squaredLength(a)`\n\n@returnNumber}\n\n\n### dot\n\nCalculates the dot product of two quat's\n\n`quaternion.dot(a, b)`\n\n\n### getAxisAngle\n\nGets the rotation axis and angle for a given quaternion.\n\n`quaternion.getAxisAngle()`\n\nIf a quaternion is created with setAxisAngle, this method will return the same values as providied in the original parameter list OR functionally equivalent values.\n\nExample: The quaternion formed by axis [0, 0, 1] and angle -90 is the same as the quaternion formed by [0, 0, 1] and 270. This method favors the latter.\n\n\n### rotationTo\n\nSets a quaternion to represent the shortest rotation from one vector to another. Both vectors are assumed to be unit length.\n\n`quaternion.rotationTo(vectorA, vectorB)`\n\n\n### add\n\nAdds two quaternions\n\n`quaternion.add(a, b)`\n\n\n### calculateW\n\nCalculates the W component of a quat from the X, Y, and Z components. Any existing W component will be ignored.\n\n`quaternion.calculateW()`\n\n\n### conjugate\n\nCalculates the conjugate of a quat If the quaternion is normalized, this function is faster than quat_inverse and produces the same result.\n\n`quaternion.conjugate()`\n\n\n### invert\n\nCalculates the inverse of a quat\n\n`quaternion.invert()`\n\n\n### lerp\n\nPerforms a linear interpolation between two quat's\n\n`quaternion.lerp(a, b, t)`\n\n\n### multiply\n\nMultiplies two quat's\n\n`multiply(a, b)`\n\n\n### normalize\n\nNormalize a quat\n\n\n### rotateX\n\nRotates a quaternion by the given angle about the X axis\n\n`rotateX(rad)`\n\n\n### rotateY\n\nRotates a quaternion by the given angle about the Y axis\n\n`rotateY(rad)`\n\n\n### rotateZ\n\nRotates a quaternion by the given angle about the Z axis\n\n`rotateZ(rad)`\n\n\n### scale\n\nScales a quat by a scalar number\n\n`scale(b)`\n\n\n### set\n\nSet the components of a quat to the given values\n\n`set(i, j, k, l)`\n\n\n### setAxisAngle\n\nSets a quat from the given angle and rotation axis, then returns it.\n\n`setAxisAngle(axis, rad)`\n\n\n### slerp\n\nPerforms a spherical linear interpolation between two quaternions\n\n`slerp({start = [0, 0, 0, 1], target, ratio})`\n\ns\n","slug":"modules/core/docs/api-reference/quaternion","title":"Quaternion"},{"excerpt":"Math Utility Functions GLSL math function equivalents. Work on both single values and vectors. Usage Setting configuration Functions…","rawMarkdownBody":"# Math Utility Functions\n\nGLSL math function equivalents. Work on both single values and vectors.\n\n\n## Usage\n\n```js\nimport {config, equals} from 'math.gl';\n```\n\nSetting configuration\n```js\nimport {config} from 'math.gl';\nconfig.EPSILON = 1e-12;\nconfig.debug = true;\nconfig.printRowMajor = true;\nconfig.precision = 4;\n```\n\n## Functions\n\n#### configure\n\n`configure(options)`\n\n\n#### checkNumber\n\n`checkNumber(value)`\n\n\n#### formatValue\n\n`formatValue(value, precision = config.precision || 4)`\n\n\n#### isArray\n\nReturns true if value is either an array or a typed array\n\n`isArray(value)`\n\nNote: does not return true for ArrayBuffers and DataViews\n\n\n#### clone\n\n`clone(array)If the array has a clone function, calls it, otherwise returns a copy`\n\n\n#### toRadians\n\n`toRadians(degrees)`\n\nWorks on single values and vectors\n\n\n#### toDegrees\n\n`toDegrees(radians)`\n\nWorks on single values and vectors\n\n\n#### equals\n\n`equals(a, b, epsilon)`\n\n- Works on single values and vectors\n- Numeric values need to be closer than `config.EPSILON`\n- Objects will be compared with their `.equals()` method if present.\n\n\n#### exactEquals\n\n`exactEquals(a, b)`\n\n- Works on single values and vectors.\n- Numeric values need to be exactly identical\n- Objects will be compared with their `.exactEquals()` method if present.\n\n\n## GLSL equivalents\n\n#### radians\n\n`radians(degrees)`\n\nGLSL equivalent: Works on single values and vectors\n\n\n#### degrees\n\n`degrees(radians)`\n\nGLSL equivalent: Works on single values and vectors\n\n\n#### sin\n\n`sin(radians)`\n\nGLSL equivalent: Works on single values and vectors\n\n\n#### cos\n\n`cos(radians)`\n\nGLSL equivalent: Works on single values and vectors\n\n\n#### tan\n\n`tan(radians)`\n\nGLSL equivalent: Works on single values and vectors\n\n\n#### asin\n\n`asin(radians)`\n\nGLSL equivalent: Works on single values and vectors\n\n\n#### acos\n\n`acos(radians)`\n\nGLSL equivalent: Works on single values and vectors\n\n\n#### atan\n\n`atan(radians)`\n\n\n#### clamp\n\n`clamp(value, min, max)`\n\n\n## Remarks\n\n* When setting global configs, you may need to consider the order of code loadint when using `imports` and `requires`\n","slug":"modules/core/docs/api-reference/utilities","title":"Math Utility Functions"},{"excerpt":"SphericalCoordinates (Experimental) Note this class is considered experimental and must be imported from the  namespace.\nThis documentation…","rawMarkdownBody":"# SphericalCoordinates (Experimental)\n\n> Note this class is considered experimental and must be imported from the `experimental` namespace.\n> This documentation is incomplete and may be incorrect\n\n```js\nclass SphericalCoordinates\n```\n\nSee also [Wikipedia](https://en.wikipedia.org/wiki/Spherical_coordinate_system), [Wolfram MathWorld](http://mathworld.wolfram.com/SphericalCoordinates.html).\n\n* The poles (phi) are at the positive and negative y axis.\n* The equator starts at positive z.\n\nConversion from spherical to Cartesian (rectilinear) coordinates:\n\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n<mfenced open=\"{\" close=\"\">\n<mtable columnalign=\"left\">\n  <mtr><mrow><mi>x</mi><mo>=</mo><mn>ρ</mn><mi>cos</mi><mn>θφ</mn></mrow></mtr>\n  <mtr><mrow><mi>y</mi><mo>=</mo><mn>ρ</mn><mi>cos</mi><mn>θφ</mn></mrow></mtr>\n  <mtr><mrow><mi>z</mi><mo>=</mo><mn>ρ</mn><mi>cos</mi><mn>θφ</mn></mrow></mtr>\n</mtable>\n</mfenced>\n</math>\n\n\nConversion from Cartesian (rectilinear) to spherical coordinates:\n\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n<mfenced open=\"{\" close=\"\">\n<mtable columnalign=\"left\">\n  <mtr><mrow><mi>r</mi><mo>=</mo><msqrt>\n    <msup><mi>x</mi><mn>2</mn></msup><mo>+</mo>\n    <msup><mi>y</mi><mn>2</mn></msup><mo>+</mo>\n    <msup><mi>z</mi><mn>2</mn></msup>\n  </msqrt></mrow></mtr>\n  <mtr><mrow><mi>θ</mi><mo>=</mo><mo>arccos</mo><mfrac><mi>z</mi><mi>r</mi></mfrac></mrow></mtr>\n  <mtr><mrow><mi>φ</mi><mo>=</mo><mo>arctan</mo><mfrac><mi>y</mi><mi>x</mi></mfrac></mrow></mtr>\n</mtable>\n</mfenced>\n</math>\n\nRanges\n\n<math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n<mfenced open=\"{\" close=\"\">\n<mtable columnalign=\"left\">\n  <mtr><mrow><mi>r</mi><mo>≥<mn>0</mn></mtr>\n  <mtr><mrow><mi>θ</mi><mo>≥<mn>0</mn></mtr>\n  <mtr><mrow><mi>φ</mi><mo>≥<mn>0</mn></mtr>\n</mtable>\n</mfenced>\n</math>\n\n\n## Usage\n\n```js\nimport {_SphericalCoordinates as SphericalCoordinates} from 'math.gl';\n```\n\nCreating a SphericalCoordinates object\n```js\nconst spherical = new SphericalCoordinates({phi: 0, theta: 0});\nconst spherical = new SphericalCoordinates({pitch: 0, bearing: 0});\nconst spherical = new SphericalCoordinates({longitude: 0, latitude: 0});\n```\n\nConverting to a direction `Vector3`\n```js\nconst direction = new SphericalCoordinates().toVector3();\n```\n\nManipulating spherical coordinates;\n```js\nspherical.bearing += 3; // Add three degrees to bearing\nspherical.theta -= Math.PI / 4; // Subtract PI/4 radians from theta.\n```\n\n\n## Members\n\n// Standard spherical coordinates\n### phi\n### theta\n### radius\n### altitude\n\n// lnglatZ coordinates\n### lng\n### lat\n### z\n\n\n## Methods\n\n### constructor\n\n```js\nSphericalCoordinates({phi = 0, theta = 0, radius = 1.0})\nSphericalCoordinates({bearing = 0, pitch = 0, altitude = 1.0})\nSphericalCoordinates({longitude = 0, latitude = 0, z = 1.0})\n```\n\n* phi=0 - rotation around X (latitude)\n* theta=0 - rotation around Y (longitude)\n* radius=1 - Distance from center\n\n### set\n\n`set(radius, phi, theta)`\n\n### clone\n\n`clone()`\n\n### copy\n\n`copy(other)`\n\n### fromLngLatZ\n\n`fromLngLatZ([lng, lat, z])`\n\n### fromVector3\n\n`fromVector3(v)`\n\n### makeSafe\n\n`makeSafe()`\n\n// restrict phi to be betwee EPS and PI-EPS\n\n\n### toVector3\n\n`toVector3(center = [0, 0, 0])`\n\n// TODO - add parameter for orientation of sphere? up vector etc?\n\n### check()\n\n\n## Remarks\n\n* Inspired by THREE.js `THREE.Spherical` class\n","slug":"modules/core/docs/api-reference/spherical-coordinates","title":"SphericalCoordinates (Experimental)"},{"excerpt":"Matrix4 A 4x4 matrix. Any arguments can be plain JavaScript arrays or other  objects. Usage Copy a matrix to a  so that it can be…","rawMarkdownBody":"# Matrix4\n\nA 4x4 matrix. Any arguments can be plain JavaScript arrays or other `math.gl` objects.\n\n## Usage\n\n```js\nimport {Matrix4} from `math.gl`;\n```\n\nCopy a matrix to a `Matrix4` so that it can be manipulated (and mutated) with `Matrix4` methods:\n```js\nconst IDENTITY = [1, 0, ..., 1];\nconst m = new Matrix4(IDENTITY).translate([1, 0, 0]);\n```\n\nCreate a perspective projection matrix\n```js\nconst projectionMatrix = new Matrix4().perspective({fov, aspect, near, far})\n```\n\nCreate an orthograhic projection matrix\n```js\n```\n\nInvert a matrix\n```js\nconst inverse = matrix.invert();\n```\n\nTransform a vector as a point (including translations)\n```js\nconst transform = new Matrix4();\nconst vector2 = transform.transformPoint([0, 0]);\nconst vector3 = transform.transformPoint([0, 1, 2]);\nconst vector4 = transform.transformPoint([0, 1, 2, 1]);\n```\n\nTransform a vector as a direction (NOT including translations)\n```js\nconst transform = new Matrix4();\nconst vector2 = transform.transformDirection([0, 0]);\nconst vector3 = transform.transformDirection([0, 1, 2]);\nconst vector4 = transform.transformDirection([0, 1, 2, 1]);\n```\n\n## Inheritance\n\n`class Matrix4 extends [Matrix](./docs/api-reference/matrix) extends [MathArray](./docs/api-reference/math-array) extends [Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)`\n\n## Methods\n\nMany of the most commonly used methods are inherited from [`MathArray`](./docs/api-reference/math-array.md):\n\n* `matrix4.clone()`\n* `matrix4.copy(array)`\n* `matrix4.set(...args)`\n* `matrix4.fromArray(array, offset = 0)`\n* `matrix4.toString()`\n* `matrix4.toArray(array = [], offset = 0)`\n* `matrix4.equals(array)`\n* `matrix4.exactEquals(array)`\n* `matrix4.validate(array = this)`\n* `matrix4.check(array = this)`\n* `matrix4.normalize()`\n\nNote that `Matrix4` is a subclass of the built in JavaScript `Array` and can thus e.g. be supplied as a parameter to any function expecting an `Array`.\n\n\n### constructor\n\nCreates an empty `Matrix4`\n\n`new Matrix4()`\n\n\n### identity\n\nSets the matrix to the multiplicative identity matrix.\n\n`matrix4.identity()`\n\n\n### set\n\nSets the elements of the matrix.\n\n`matrix4.set(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33)`\n\n\n### fromQuaternion\n\nSets the matrix to a transformation corresponding to the rotations represented by the given quaternion.\n\n`matrix4.fromQuaternion(quaternion)`\n\n* `quaternion` (`Quaternion`) - the quaternion  to create matrix from\n\n\n### frustum\n\nGenerates a frustum matrix with the given bounds. The frustum far plane can be infinite.\n\n`matrix4.frustum({left, right, bottom, top, near, far})`\n* `left` (`Number`) - Left bound of the frustum\n* `right` (`Number`) - Right bound of the frustum\n* `bottom` (`Number`) - Bottom bound of the frustum\n* `top` (`Number`) - Top bound of the frustum\n* `near` (`Number`) - Near bound of the frustum\n* `far` (`Number`|`Infinity`) - Far bound of the frustum\n\n\n### lookAt\n\nGenerates a look-at matrix with the given eye position, focal point, and up axis\n\n`matrix4.lookAt({eye, center, up})`\n* `eye` (`Vector3`|`Number[3]`) - Position of the viewer\n* `center` (`=`) - 0, 0, 0]  vec3  Point the viewer is looking at\n* `up` (`=`) - 0, 1, 0]  vec3  vec3 pointing up\n\n\n### ortho\n\nGenerates a orthogonal projection matrix with the given bounds\n\n`matrix4.ortho({left, right, bottom, top, near = 0.1, far = 500})`\n* `left` (`Number`) - Left bound of the frustum\n* `right` (`Number`) - Right bound of the frustum\n* `bottom` (`Number`) - Bottom bound of the frustum\n* `top` (`Number`) - Top bound of the frustum\n* `near` (`Number`) - Near bound of the frustum\n* `far` (`Number`) - Far bound of the frustum\n\n\n### orthographic\n\nGenerates an orthogonal projection matrix with the same parameters\nas a perspective matrix (plus `focalDistance`).\n\n* Matrix4.orthographic({fovy, aspect, focalDistance, near, far})\n\n* `fovy` (`Number`) - Vertical field of view in radians\n* `aspect` (`Number`) - Aspect ratio. typically viewport width/height\n* `focalDistance` (`Number`) - selects which plane in the perspective view frustum should be used to calculate the size of the orthographic view box.\n* `near`=`0.1` (`Number`) - Near bound of the frustum\n* `far`=`500` (`Nmber`) - Far bound of the frustum\n\n> In applications it is not unusual to want to offer both perspective and orthographic views and this method is supplied to make this as simple as possible.\n\n\n### perspective\n\nGenerates a perspective projection matrix with the given bounds. The frustum far plane can be infinite.\n\n`matrix4.perspective({\n  fovy = 45 * Math.PI - / 180,\n  aspect = 1,\n  near = 0.1,\n  far = 500\n})`\n* `fovy`=`45` (`Number`) - Vertical field of view in radians (default is 45 degrees specified in radians)\n* `aspect`=`1` (`Number`) - Aspect ratio. typically viewport width/height\n* `near`=`0.1` (`Number`) - Near bound of the frustum\n* `far`=`500` (`Number`|`Infinity`) - Far bound of the frustum\n\n\n### determinant()\n\nReturns the determinant of the matrix (does not modify the matrix).\n\n`const determinant = matrix4.determinant()`\n\nReturns (`Number`) - the determinant\n\n* If the determinant is zero, the matrix is not invertible.\n* Determinant calculation is somewhat expensive.\n\n\n### transpose\n\nSets this matrix to its transpose matrix.\n\n`matrix4.transpose()`\n\n* The transpose matrix mirrors the original matrix elements in the diagonal.\n\n\n### invert\n\nSets this matrix to its inverse matrix.\n\n`matrix4.invert()`\n\n* The inverse matrix mirrors the original matrix elements in the diagonal.\n\n\n### multiplyLeft\n\nMultiplies in another matrix from the left\n\n`matrix4.multiplyLeft(matrix4)`\n\n* When using `Matrix4` to transform vectors, the vectors are multiplied in from the right. This means that the multiplying in a matrix from the left will cause it to be applied last during transformation (unless additional matrices are multiplied in from the left of course).\n\n\n### multiplyRight\n\n`matrix4.multiplyRight(matrix4)`\n\n* When using `Matrix4` to transform vectors, the vectors are multiplied in from the right. This means that the multiplying in a matrix from the left will cause it to be applied last during transformation (unless additional matrices are multiplied in from the left of course).\n\n### rotateX\n\nAdds a rotation by the given angle around the X axis. Equivalent to right multiplying the new transform into the matrix but more performant.\n\n`matrix4.rotateX(radians)`\n\n\n### rotateY\n\nAdds a rotation by the given angle around the Y axis.\n\n`rotateY(radians)`\n\n* Equivalent to right multiplying the new transform into the matrix but more performant.\n\n\n### rotateZ\n\nAdds a rotation by the given angle around the Z axis.\n\n`matrix4.rotateZ(radians)`\n\n* Equivalent to right multiplying the new transform into the matrix but more performant.\n\n\n### rotateXYZ([rx, ry, rz])\n\nAdds successive rotations by the given angles around the X, Y and Z axis.\n\n`rotateXYZ([rx, ry, rz])`\n\n* Equivalent to right multiplying the new transform into the matrix but more performant.\n\n\n### rotateAxis(radians, axis)\n\nAdds successive rotations by the given angles around the X, Y and Z axis.\n\n`rotateAxis(radians, axis)`\n\nEquivalent to right multiplying the new transform into the matrix but more performant.\n\n\n### scale\n\nAdds a scaling transform, each axis can be scaled independently.\n\n`matrix4.scale(factor)`\n* `factor` (Number) - scale factor to be applied to each axis.\n\n`matrix4.scale([x, y, z])`\n* `x` (Number) - scale factor to be multiplied into x component\n* `y` (Number) - scale factor to be multiplied into y component\n* `z` (Number) - scale factor to be multiplied into z component\n\nEquivalent to right multiplying the new transform into the matrix but more performant.\n\n* During vector transformation all coordinates will be multiplied with the given factors.\n* Scale with `-1` will flip the coordinate system in that axis.\n* Scale with `0` will drop that component.\n\n\n### translate\n\nAdds a translation to the matrix.\n\n`matrix4.translate([x, y, z])`\n* `x` (Number) - translation to be added to the x component\n* `y` (Number) - translation to be added to the y component\n* `z` (Number) - translation to be added to the z component\n\nEquivalent to right multiplying the new transform into the matrix but more performant.\n\nDuring vector transformation the given translation values are added to each component of the vector being transformed.\n\n\n### transformPoint(vector : Number[4]) : Number[4]\n\nTransforms any 2, 3 or 4 element vector as a \"point\" by multiplying it (from the right) with this matrix. `Point` here means that the returned vector will include any translations in this matrix.\n\n`const vector = matrix4.transformPoint(vector, out=)`\n\n* `vector` (`Array`|`Vector2`|`Vector3`|`Vector4`)\n* `out` - unless supplied, will be a Vector2, Vector3 or Vector4, matching the length of input vector.\nReturns `out`, or a newly minted `Vector2`, `Vector3` or `Vector4`\n\n* If `vector` is specified in homogeneous coordinates, `w` coordinate must NOT be `0`.\n* If `vector` is specified in homogeneous coordinates the returned vector will be `w` adjusted, (i.e. `w` coordinate will be `1`, even if the supplied vector was not normalized).\n\n\n### transformDirection(vector : Number[4]) : Number[4]\n\nTransforms any 2, 3 or 4 element vector interpreted as a direction (i.e. all vectors are based in the origin so the transformation not pick up any translations from the matrix).\n\n`const vector = matrix4.transformDirection(vector, out)`\n\n* If `vector` is specified in homogeneous coordinates, `w` coordinate must be `0`.\n\n\n### transformVector(vector : Number[4]) : Number[4] \\(DEPRECATED)\n\nConfusingly corresponds to `transformPoint`.\n\n`transformVector(vector, out)`\n\n* `vector` (`Array`|`Vector2`|`Vector3`|`Vector4`)\n* `out` - unless supplied, will be a Vector2, Vector3 or Vector4, matching the length of input vector.\nReturns `out`, or a newly minted `Vector2`, `Vector3` or `Vector4`\n\n\n### transformByMatrix3(vector : Number[4]) : Number[4]\n\nTransforms\n\n### transformByMatrix2(vector : Number[4]) : Number[4]\n\n\n## Remarks\n\n* All transforms are effectively \"right multiplied\" onto the matrix (meaning that during transform they will be applied in opposite order).\n* `Matrix4` is stored internally in column major format (per WebGL conventions). This only matters when you read out the matrix to use it with other software.\n","slug":"modules/core/docs/api-reference/matrix4","title":"Matrix4"},{"excerpt":"Vector  is a base class for ,  and , providing common methods to those classes. Inheritance  Methods Vector.clone() Vector.copy(array…","rawMarkdownBody":"# Vector\n\n`Vector` is a base class for [`Vector2`](./docs/api-reference/vector2), [`Vector3`](./docs/api-reference/vector3) and [`Vector4`](./docs/api-reference/vector4), providing common methods to those classes.\n\n## Inheritance\n\n`class Vector extends [MathArray](./docs/api-reference/math-array) extends [Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)`\n\n## Methods\n\n#### Vector.clone()\n#### Vector.copy(array)\n#### Vector.set(...args)\n#### Vector.fromArray(array, offset = 0)\n#### Vector.toString()\n#### Vector.toArray(array = [], offset = 0)\n#### Vector.equals(array)\n#### Vector.exactEquals(array)\n#### Vector.validate(array = this)\n#### Vector.check(array = this)\n#### Vector.normalize()\n","slug":"modules/core/docs/api-reference/vector","title":"Vector"},{"excerpt":"Vector3 Usage Accessors Simple rotations Scaling with constants Scaling with vectors is very flexible, you can e.g. set a component to zero…","rawMarkdownBody":"# Vector3\n\n```js\nclass Vector3 extends MathArray extends Array\n```\n\n## Usage\n\n```js\nimport {Vector3} from 'math.gl';\nconst vector = new Vector3(1, 1, 1);\n```\n\nAccessors\n```js\nv.x = 2;\nassert(v[0] === v.x);\n```\n\nSimple rotations\n```js\nconst v = new Vector3([1, 0, 0]);\nv.rotateX({radians: Math.PI / 4}); // Rotate around the origin\nv.rotateX({radians: Math.PI / 4, origin: [1, 1, 0]}); // Rotate around the specified point\n```\n\nScaling with constants\n```js\nconst u = v.scale(-1); // Reverse direction vector\n```\n\nScaling with vectors is very flexible, you can e.g. set a component to zero, or flip a component's sign.\n```js\nconst u = v.scale([1, 1, 0]); // Set z component to zero\nconst w = v.scale([1, -1, 1]); // Flip y component\n```\n\n## Inheritance\n\n`Vector3` extends [`Vector`](./docs/api-reference/vector) extends [`MathArray`](./docs/api-reference/math-array) extends [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)\n\n## Members\n\n### x, y, z\n\nGets or sets element 0, 1 or 2 respectively\n\n\n## Methods\n\nMany of the most commonly used `Vector3` methods are inherited from [`MathArray`](./docs/api-reference/math-array.md):\n\n* `Vector3.clone()`\n* `Vector3.copy(array)`\n* `Vector3.set(...args)`\n* `Vector3.fromArray(array, offset = 0)`\n* `Vector3.toString()`\n* `Vector3.toArray(array = [], offset = 0)`\n* `Vector3.equals(array)`\n* `Vector3.exactEquals(array)`\n* `Vector3.validate(array = this)`\n* `Vector3.check(array = this)`\n* `Vector3.normalize()`\n\nNote that `Vector3` is a subclass of the built in JavaScript `Array` and can thus e.g. be supplied as a parameter to any function expecting an `Array`.\n\n\n### constructor(x = 0, y = 0, z = 0)\n\n### set(x, y, z)\n\n### length()\n\n### distance(vector)\n\n### angle(vector)\n\n### dot(vector)\n\n// MODIFIERS\n\n### add(...vectors)\n\n### subtract(...vectors)\n\n### multiply(...vectors)\n\n### divide(...vectors)\n\n### scale(scale)\n\nScale component wise with a scalar or another `Vector3`.\n\n* `scale` (Number|Vector3) - scale component wise with a scalar or another `Vector3`.\n\n\n### negate\n\n`negate()`\n\n\n### inverse\n\n\n\n`inverse()`\n\n### normalize\n\n`normalize()`\n\n### cross\n\n`cross(vector)`\n\n### lerp\n\n`lerp(vector, coeff)`\n\n### rotateX\n\nRotate a 3D vector around the x-axis\n\n`rotateX({radians, origin})`\n\n* `radians` (Number) - angle to rotate.\n* `origin`=`[0, 0, 0]` (Vector3) - the origin of the rotation (optional)\n\n\n### rotateY\n\nRotate a 3D vector around the y-axis\n\n`rotateY({radians, origin})`\n\n* `radians` (Number) - angle to rotate.\n* `origin`=`[0, 0, 0]` (Vector3) - the origin of the rotation (optional)\n\n\n### rotateZ(radians)\n\nRotate a 3D vector around the z-axis\n\n`rotateZ({radians, origin})`\n\n* `radians` (Number) - angle to rotate.\n* `origin`=`[0, 0, 0]` (Vector3) - the origin of the rotation (optional)\n\n\n### transform(matrix4 : Number[16]) : Vector4\n\nTransforms the vector by the provided 4x4 matrix.\n\nNote: Scales the resulting vector to ensure that `w`, if non-zero, is set to `1`.\n\n### transformByMatrix3(matrix3 : Number[9]) : Vector4\n\nTransforms the vector by the provided 3x3 matrix.\n\n### transformByMatrix2(matrix2 : Number[4]) : Vector4\n\nTransform the vector's `x` and `y` values by the provided 2x2 matrix.\n\n### transformByQuaternion(quaternion : Number[4]) : Vector4\n\nTransform the vector by the provided `quaternion`.\n","slug":"modules/core/docs/api-reference/vector3","title":"Vector3"},{"excerpt":"Vector4  is designed to hold three dimensional coordinates in projective space. Using the projective representation allows JavaScript…","rawMarkdownBody":"# Vector4\n\n`Vector4` is designed to hold three dimensional coordinates in projective space. Using the projective representation allows JavaScript applications to perform the same calculations that the GPU does.\n\nA main feature of vectors is that they can be transformed by matrices and quaternions. And `Vector4`s are particular general when transformed with 4x4 matrices (`Matrix4` or just arrays of 16 numbers), as those can include translations, projections and other transformations that cannot be expressed by e.g. 3x3 matrices or quaternions alone.\n\nNote that the fourth element `w` is not a coordinate but a scaling factor. The fourth component (`w`) is usually set to either\n- `0` to represent a vector\n- `1` to represent a point\n\n`Vector4` methods will keep the vector scaled so that `w` (if non-zero) is `1`.\n\nThe math behind `Vector4` comes from projective geometry, which significantly generalizes calculations and removes a number of special cases compared to affine geometry. It is not necessary to understand the details to use `Vector4`, but see the developer guide for some additional xbackground.\n\n## Usage\n\n```js\nimport {Vector4} from 'math.gl';\nconst vector = new Vector4(1, 1, 1, 0);\nconst point = new Vector4(0, 0, 0, 1);\n```\n\n## Inheritance\n\n`Vector4` extends [`Vector`](./docs/api-reference/vector) extends [`MathArray`](./docs/api-reference/math-array) extends [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)\n\n## Members\n\n### x, y, z, w\n\nGets or sets element 0, 1, 2 or 3 respectively\n\n\n## Methods\n\nMany of the most commonly used `Vector2` methods are inherited from [`MathArray`](./docs/api-reference/math-array.md):\n\n* `Vector4.clone()`\n* `Vector4.copy(array)`\n* `Vector4.set(...args)`\n* `Vector4.fromArray(array, offset = 0)`\n* `Vector4.toString()`\n* `Vector4.toArray(array = [], offset = 0)`\n* `Vector4.equals(array)`\n* `Vector4.exactEquals(array)`\n* `Vector4.validate(array = this)`\n* `Vector4.check(array = this)`\n* `Vector4.normalize()`\n\nNote that `Vector2` is a subclass of the built in JavaScript `Array` and can thus e.g. be supplied as a parameter to any function expecting an `Array`.\n\n\n### constructor(x? : Number, y? : Number, z? : Number, w? : Number)\n\n`new Vector4(x = 0, y = 0, z = 0, w = 0)`\n\nCreates a new, empty `Vector4`\n\n### set(x? : Number, y? : Number, z? : Number, w? : Number) : Vector4\n\nUpdates a `Vector4`\n\n### distance(vector : Number[4]) : Vector4\n\nReturns the distance to the specifed Vector.\n\n### distanceSquared(vector : Number[4]) : Vector4\n\nReturns the squared distance to the specifed Vector. Fast to calculate than distance and often sufficient for e.g. sorting etc.\n\n### dot(vector : Number[4]) : Number\n\nCalculates the dot product with the supplied `vector`.\n\n### add(vector : Number[4]) : Vector4\n\n`add(...vectors)`\n\n### subtract(vector : Number[4]) : Vector4\n\n`subtract(...vectors)`\n\n### multiply(vector : Number[4]) : Vector4\n\n`multiply(...vectors)`\n\n### divide(vector : Number[4]) : Vector4\n\n`divide(...vectors)`\n\n### scale(vector : Number[4]) : Vector4\n\n`scale(scale)`\n\n### negate() : Vector4\n\nNegates each element in the vector.\n\n### inverse() : Vector4\n\nInverses (`x = 1/x`) each element in the vector.\n\n### normalize() : Vector4\n\nNormalizes the vector. Same direction but `len()` will now return `1`.\n\n### lerp(vector : Number[4], coefficient : Number) : Vector4\n\nLinearly interpolates between the vectors current value and the supplied `vector`.\n\n### transform(matrix4 : Number[16]) : Vector4\n\nEquivalent to `transformByMatrix4`.\n\n### transformByMatrix4(matrix4 : Number[16]) : Vector4\n\nTransforms a vector by the provided 4x4 matrix.\n\nNote: Scales the resulting vector to ensure that `w`, if non-zero, is set to `1`.\n\n### transformByMatrix3(matrix3 : Number[9]) : Vector4\n\nTransforms the vector's `x`, `y` and `z` values by the provided 3x3 matrix.\n\n### transformByMatrix2(matrix2 : Number[4]) : Vector4\n\nTransform the vector's `x` and `y` values by the provided 2x2 matrix.\n\n### transformByQuaternion(quaternion : Number[4]) : Vector4\n\nTransform the vector by the provided `quaternion`.\n","slug":"modules/core/docs/api-reference/vector4","title":"Vector4"},{"excerpt":"3D Coordinate Systems Note: This article is a work in progress and may contain incorrect information. There are many possible ways to…","rawMarkdownBody":"# 3D Coordinate Systems\n\n> Note: This article is a work in progress and may contain incorrect information.\n\n\nThere are many possible ways to represent points in space using coordinates, e.g. rectangular, elliptical, polar/spherical, etc. Which coordinate system is the best depends entirely on the problem at hand. When working with specific geometrical problems, it is often the case that the required mathematical operations become more simple in a certain coordinate system which means that it is worth being familiar both with a few different coordinate system and also how to convert between them.\n\nmath.gl provides support for a couple of 3D coordinate systems:\n* Rectilinear (`Vector3`) - Typically used to represent standard Cartesian space\n* Spherical (`SpericalCoordinates`) - Two angles representing point on sphere and a distance from center\n* Projective/Homogeneous (`Vector4`) - These are coordinates in \"projective\" 3-space. The purpose of these is explained in [link](./'homogeneous-coordinates.md')\n\n\n## Converting between Coordinate Systems\n\nNote that each coordinate system ultimately specifies the same point\n\n\n\n\n## Converting within Coordinate Systems\n\n\n\n## Remarks\n\n* Note that a similar situation applies for [rotations](./rotations), where different representations are possible (e.g. Euler angles, Quaternions, Axis/angle, 4x4 matrices) and the choice of a \"best\"  representation often depends on the problem at hand.\n","slug":"modules/core/docs/developer-guide/coordinate-systems","title":"3D Coordinate Systems"},{"excerpt":"Debugging Note: This article is a work in progress and may contain incorrect information. About Validation and Debug Support TBA: Turning on…","rawMarkdownBody":"# Debugging\n\n> Note: This article is a work in progress and may contain incorrect information.\n\n\n## About Validation and Debug Support\n\nTBA:\n* Turning on an off\n* performance implications\n\n\n## About \"Printing\"\n\nGenerating a string representation of a math.gl object with desired precision and formatting.\n\nEvery math.gl object has a `formatString({...opts})` method that allows you to stringify an object with special options set. Each object also defines the built-in JavaScript function `toString()` to call `formatString()` with the global printing options in the math.gl `config` object.\n\n\n\n* `toString` and `formatString` methods print with controllable precision\n\n\n| Print Parameter | Default | Description |\n| --- | --- | --- |\n| `printPrecision` | `4` | Number of significant digits |\n| `printTypes` | `false` | Prints the name of the math.gl type (e.g. `Vector3[...]` instead of `[...]` |\n| `printDegrees` | `false` | Prints degrees instead of radians (e.g. for `Euler` and `SphericalCoordinates`) |\n| `printRowMajor` | `true` | Prints matrices as row major which makes them look more familiar instead of as column major (which is how they are stored internally for WebGL compatibility). |\n","slug":"modules/core/docs/developer-guide/debugging","title":"Debugging"},{"excerpt":"Using with Other Frameworks math.gl is designed to be (reasonably) interoperable with other major math frameworks. Using with gl-matrix Note…","rawMarkdownBody":"# Using with Other Frameworks\n\nmath.gl is designed to be (reasonably) interoperable with other major math frameworks.\n\n\n## Using with gl-matrix\n\n> Note: This article is a work in progress and may contain incorrect information.\n\n\n### API comparison\n\nThe math.gl API is intentionally designed to remain intuitively similar to the wrapped `gl-matrix` procedures, usually just removing the first one or two parameters from each function (the out argument and the first input arguments, both are implictly set to `this`), and exposes the remaining arguments in the same order as the gl-matrix api.\n\nOnly in a few cases where `gl-matrix` methods take a long list arguments (e.g. `Matrix4.perspective`, `Matrix4.ortho` etc) or return multiple values (e.g. `quat.getAxisRotation`) do methods provide a modified API that is more natural for modern ES6 applications to use, e.g. using named parameters, or collecting all results in one returned object.\n\nAlso, for transforming vectors with matrices, the `transform*` methods are offered in the matrix classes, instead of on the vector classes. They also (optionally) auto allocate the result vectors.\n\nIn code that is very frequently executed, working with directly with gl-matrix can sometimes provide better performance math.gl.\n\n\n## References\n\n* Top learn more about gl-matrix. The [gl-matrix docs](http://glmatrix.net/docs/) are a good start. Additionally, the gl-matrix source code is partially updated with JSDoc.\n\n\n## Using with THREE.js\n\n> Note: This article is a work in progress and may contain incorrect information.\n\nmath.gl makes efforts to be compatible with the THREE.js math API.\n\n\n### Method Interoperability\n\nIn particular, the basic math.gl math classes have implementations of most of the methods that THREE.js defines.\n\n| math.gl   | THREE.js        | Notable differences   |\n| ---       | ---             | ---                   |\n| `Vector2` | `THREE.Vector2` | `length()` => `len()` |\n| `Vector3` | `THREE.Vector3` | ditto |\n| `Vector4` | `THREE.Vector4` | ditto |\n| `Matrix3` | `THREE.Matrix3` | Math.gl stores in column-major order by default |\n| `Matrix4` | `THREE.Matrix4` | ditto |\n\n\n\n* Can a THREE.Math class be created/initialized from a math.gl class? Probably yes, as we expose x, y, z accessors\n* Can a math.gl class be created/initialized from a THREE.Math class? Probably not yet, as we don't look for x, y, z.\n\n\n### Notable Incompatibilities\n\n\n#### Colum-Major vs. Row-Major Matrices\n\nBy default, math.gl stores matrices in column-major order internally (while exposing a row-major friendly interface), whereas THREE.js stores matrices in row-major order.\n\n\n#### Array.length()\n\nSince math.gl's classes are subclasses of JavaScripts built-in `Array` class, the `length` property has the special meaning defined by `Array`, so it is not possible to implement the `Vector.length()` method defined by THREE.js. Instead a `Vector.len()` method is offered on math.gl `Vector` classes.\n\n\n#### Cross-Library Convenience Methods\n\nA complication with THREE.js is that the framework is not strict about separating the library into independent layers. Thus the THREE math classes have convenience methods that accept other THREE.js objects such `Geometries` and `BufferAttributes`. These methods are not implemented in math.gl.\n\n\n### Remarks\n\n* An indicator of the level of THREE.js compatibility is the fact that math.gl includes a copy of the math test suites from THREE.js, parts of which pass cleanly when run the math.gl classes listed above (admittedly with a few disabled cases).\n* While it would of course be nice to be able to state \"100% compatiblity\" with the THREE.js math API, there are hard technical constraints. For instance, since math.gl's classes are subclasses of JavaScripts built-in `Array` class, the `length` property has the special meaning defined by `Array`, so it is not possible to implement the `Vector.length()` method defined by THREE.js.\n* Note that THREE.js compatibility methods will not always be implemented in the most performant way. Every compatibility methods adds size to the library and if they can be implemented in a compact way by calling existing methods that is often preferred over raw speed.","slug":"modules/core/docs/developer-guide/external-frameworks","title":"Using with Other Frameworks"},{"excerpt":"Floating Point Note: This article is a work in progress and may contain incorrect information. Precision About Comparisons Due to small…","rawMarkdownBody":"# Floating Point\n\n> Note: This article is a work in progress and may contain incorrect information.\n\n\n## Precision\n\n### About Comparisons\n\nDue to small rounding errors, exact equality is often not a reliable way to compare floating point numbers. Therefore the default `equals` operation checks that two numbers are within a small delta.\n\nThere is also an `exactEquals` method that compares the floating point values directly.\n\n```js\n return Math.abs(a - b) <= config.EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n```\n\nTBA:\n* Floating point comparison implementation in gl-matrix and alternatives (links)\n\n\n\n* [Comparisons](http://floating-point-gui.de/errors/comparison/)\n","slug":"modules/core/docs/developer-guide/floating-point","title":"Floating Point"},{"excerpt":"Performance The code vector and matrix operations in math.gl are based on gl-matrix which is designed as a high performance JavaScript 3D…","rawMarkdownBody":"# Performance\n\nThe code vector and matrix operations in math.gl are based on gl-matrix which is designed as a high performance JavaScript 3D math library.\n\nSince math.gl uses gl-matrix functions under the hood, math.gl's performance is usually very close to gl-matrix, but the additional conveniences in math.gl do come with a certain overhead. Understanding this overhead can help you write more performant code and work around performance issues.\n\nIn cases where javascript math calculations are performance critical, you can always use gl-matrix operations directly. See (./docs/get-started/using-with-gl-matrix.md). Essentially, since all math.gl classes inherit from `Array`s they work directly as arguments to gl-matrix functions, no copying necessary.\n\n## Disabling Debug Checks\n\nIf debug mode has been turned on, math.gl checks that objects after every operation. Enabling the checks has a modest impact on performance.\n\n```js\nimport {configure, Vector2} from 'math.gl';\nconfigure({debug: false});\nlet vector = new Vector2(NaN, NaN); // Initializes an \"invalid\" vector\n\nconfigure({debug: true});\nlet vector = new Vector2(NaN, NaN); // Now throws an error. The check\n```\n\nVerifying that error checks are not turned on.\n```js\nimport {configure} from 'math.gl';\nconsole.log('Debug status', configure().debug);\n```\n\n## Minimizing Object Creation\n\nThe biggest performance issue in math.gl (and essentially all other JavaScript math libraries) is object creation cost. Creating new `Vector3` and `Matrix4` instances every time a calculation is made incurs significant overhead.\n\nThere are two standard techniques to avoid object creation costs.\n\n#### Resuing Objects\n\nTherefore, reusing objects where possible is an important technique to optimize performance. A typical technique is to allocate a global object in the file.\n\nReplace\n\n```js\nfor (...) {\n\tconst v = new Vector3(x, y, z);\n}\n```\n\nwith\n\n```js\nconst tempVector = new Vector3();\nfor (...) {\n\tv.set(x, y, z);\n}\n```\n\nNote that while creating objects can be slow, copying data into a temo object (e.g. `vector4.copy([1, 1, 1, 1])` or `vector4.copy([1, 1, 1, 1])`) is very fast.\n\n#### Supplying `result` Objects\n\nA number of methods, such as `Matrix4.transformVector()`, allocate new objects as return values. These methods typically accept an optional `result` argument which can be populated and returned. By providing a `result` value, you revent the allocation of a new object and instead reuse an object you have already allocated.\n\n```js\nfor (...) {\n  const v = matrix4.transformVector([x, y, z]);\n  // v now contains a reference to a newly allocated `Vector3` which was updated with the result of the `tranformVector` operation.\n}\n```\nvs.\n\n```js\nconst tempVector = new Vector3();\nfor (...) {\n  const v = matrix4.transformVector([x, y, z], tempVector);\n  // v now contains a reference to `tempVector` which was updated with the result of the `tranformVector` operation.\n}\n```\n\n## Browser, OS version etc\n\nThe JavaScript engine powering Chrome and Node is still improving. The performance difference between e.g. Node 8 and Node 11 is rather staggering.\n\n\n## Benchmarking\n\nThe math.gl repository comes with a benchmark suite that you can run to see what operations are fast and which take more time in your environment.\n\nYou can run the benchmarks both in Node.js and in the browser\n\n```bash\nyarn bench\nyarn bench browser\n```\n\n## JavaScript Engine Optimizations\n\n> This section should be considered advanced, and is not required reading for the normal math.gl user. However if you are writing your own math code it can be useful to have an understanding.\n\nTo get good performance it is important to structure code so that it can be compiled and optimized by the JavaScript engine in use. math.gl focuses on optimizing for the V8 engine, since it is used both by Chrome and Node.js, however the optimizations are general and should also be relevant to other optimizing JavaScript engines.\n\nIn particular, math.gl makes efforts to ensure that the engine knows that fields in math classes contain numbers, which allows for important optimizations that can result in a \\~5x performance difference for simple operations.\n\nA good introduction to the topic can be found in [JavaScript Performance Pitfalls in V8](https://ponyfoo.com/articles/javascript-performance-pitfalls-v8).\n","slug":"modules/core/docs/developer-guide/performance","title":"Performance"},{"excerpt":"Getting Started Installation Usage","rawMarkdownBody":"# Getting Started\n\n## Installation\n\n```bash\nnpm install math.gl\n```\n\n## Usage\n\n```js\nimport {Vector2} from 'math.gl';\nconst vector = new Vector2(1, 2);\n```\n","slug":"modules/core/docs/developer-guide/get-started","title":"Getting Started"},{"excerpt":"Transformations One of the core use cases for math.gl is to perform transformations on objects (typically either vectors or more complex…","rawMarkdownBody":"# Transformations\n\nOne of the core use cases for math.gl is to perform transformations on objects (typically either vectors or more complex object such as spheres, planes, boxes etc).\n\nThere are additional articles [docs/developer-guide/concepts](./'homogeneous-coordinates.md') that provides more background about advantages when using 4x4 matrices, those transformations work in the same way from an API perspective as the ones described here.\n\n## Representing Transformations\n\nTransformations can be represented in many different notations but for computational purposes it is efficient to express them as matrices, or in some cases as quaternions.\n\n\n## Applying transformations\n\nThe most general transform is a 4x4 matrix. Most math.gl classes offer a `transform` method that accepts 4x4 matrices. Note that as usual these operations modifies the object being transformed (and returns itself).\n\n```js\nconst transformedVector1 = new Vector4(1, 0, 0, 1).transform([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])\n// or\nconst transformedVector2 = new Vector4(1, 0, 0, 1).transform(new Matrix4([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]))\n```\n\nThe various vector classes also offer methods to transform with smaller matrices\n```js\nconst transformedVector1 = new Vector4(1, 0, 0, 1).transformByMatrix3([1, 0, 0, 0, 1, 0, 0, 0, 1])\n// or\nconst transformedVector2 = new Vector3(1, 0, 0).transformByMatrix2(new Matrix2([1, 0, 0, 1]))\n```\n\nQuaternion transformations are also supported on some objects\n```js\nconst transformedVector1 = new Vector4(1, 0, 0).transformByQuaternion([0, 0, 0, 1])\n// or\nconst transformedVector2 = new Vector3(1, 0, 0).transformByQuaternion(new Quaternion([1, 0, 0, 1]))\n```\n\nNote that the transformations can also be performed via the matrix and quaternion classes. In this case, the transformation is stored in the result parameters (a new array is allocated if it `result` is not supplied.)\n```js\nconst transformedVector1 = new Vector4(1, 0, 0).transformByQuaternion([0, 0, 0, 1])\n// or\nconst result = new Vector3();\nconst transformedVector2 = new Quaternion([1, 0, 0, 1]).transformByQuaternion([1, 0, 0], result);\n```\n\n## Types of Transformations\n\nThe basic transformations are rotations, scalings, and translations.\n\n\n## Composing Transformations\n\nOne of the most powerful aspects of using matrices to manage transformations is that matrices can be multiplied together using linear algebra.\n\nThis allows us to build up a complex transformation by multiplying together component parts.\n\n`Matrix4` provides a number of transformation methods ('scale', 'rotate', 'translate', ...) that allow us to build transformation matrices. These can be applied to an identity matrix (e.g. a newly created `Matrix4`) or to a matrix that already contains other transformations.\n\n\n## Order Matters\n\nWhen composing (i.e. multiplying) matrices it is critical to consider the order in which they are being applied, as changing the order of component will in most cases change the resulting composite transformation. It is not hard to verify that this is consistent with geometric intuition by composing a few operations on paper.\n\nBecause of this the `Matrix4` class provides two matrix multiplication methods: `multiplyLeft` and `multiplyRight` that force you to make explicit what you intend when multiplying two matrices.\n\nAll `Matrix4` transformation methods ('scale', 'rotate', 'translate', ...) conceptually correspond to multiplying in a new transformation matrix from the right (although these methods internally are more efficient in that they don't create any temporary objects and they only do the minimal amount of changes to the matrix required for that specific transformation).\n\nIn the end, the point or vector to be transformed will be multiplied in from the right, which means that a typical composed transformation needs to be read in reverse order. I.e. in the example below, the vector will first be rotated, then transformed by the `partialTransform`, then scaled.\n\n```js\n// Illustrates that transformations are applied in reverse order\nconst partialTransform = new Matrix4(...);\nconst fullTransform = new Matrix4()\n  .scale([1, -1, 1])\n  .multiplyRight(partialTransform)\n  .rotateX({radians: Math.PI});\nconst v = fullTransform.transformVector(new Vector4(...));\n```\n\n\n## About Rotations\n\nFor more in-depth background about rotations, see the separate article on [rotations](./rotations.md).\n\nIf you have a vector with 3 elements you can rotate it around an axis and a point like so:\n```js\nconst v = new Vector3([1, 2, 3]).rotateZ({radians: ..., origin: [1, 1, 0]});\n```\n\n\n## Remarks\n\n* Decomposition - The ability to compose transformations raises the question whether it is possible to decompose a composite transformations into constituent parts. This is possible under certain circumstances, TBA.\n\n","slug":"modules/core/docs/developer-guide/transformations","title":"Transformations"},{"excerpt":"View and Projection Matrices Projections in math.gl are concerned with projecting 3D coordinates to a 2D plane (the screen). View and…","rawMarkdownBody":"## View and Projection Matrices\n\nProjections in math.gl are concerned with projecting 3D coordinates to a 2D plane (the screen).\n\n\n## View and Projection Matrices\n\nTo set up a 4x4 view projection matrix you need a view matrix (specifying the position, direction and orientation of the camera) and a projection matrix (specifying the characteristics of the camera such as its field of view etc).\n\nThe purpose of the view matrix is to translate and rotate your world coordinates so that the eye is located in the origin `[0, 0, 0]`, looking down the positive `Z` axis, rotated so that the right direction is `up`. This is called the \"view coordinate system\".\n\nThe purpose of the projection matrix is to transform from view coordinates to \"clipspace\" coordinates (which is the only coordinate system that the GPU can work directly with). If a point is between `-1` and `1` (after `w` scaling) in clipspace, it will be rendered. The `z` coordinate in clipspace is also scaled (using 'near' and 'far' planes) and if between `-1` and `1` it is used for depth test.\n\nNote: while a projection matrix may generate coordinates with `w !== 1`, the GPU will automatically divide the `xyzw` coordinates with the `w` coordinateof any positions it receives thus and \"normalize\" the `w` coordinate. Thus, there is no need to do this scaling manually in shaders unless doing additional arithmetic in clipspace.\n\n\n### Creating a View Matrix\n\nTo create a view matrix\n* `Matrix4.lookAt({...})`\n\nNormally positions are transformed by the view matrix. If doing work (e.g. lighting) in view space you will also want to transform other geometry such as normals.\n\n\n## Projection Matrices\n\nProjection matrices typically show everything inside a frustum (truncated pyramid) or a cube in the view space. Their job is to \"scale\" or \"skew\" the geometry inside this virtual shape into the clipspace cube, which is the coordinate system the GPU takes as input.\n\n### Perspective Projection Matrix\n\nTo create a projection matrix use:\n* `Matrix4.perspective({fov, aspect, near, far})`\n\n\n### Creating an Orthographic Projection Matrix\n\nmath.gl provides the traditional function create an orhtographic projection matrix by providing the \"box\" extents:\n\n* `Matrix4.ortho({right, left, top, bottom, near, far})`\n\nThe extents are specified in \"view space\" (which is typically translated and rotated, but not scaled, world space).\n\n\n### Switching between Perspective and Orthographic Views\n\nIn applications it is not unusual to want to offer both perspective and orthographic views. To support this case, math.gl offers an additional method for creating orthographic projection matrix, that takes the same parameters as `Matrix4.perspective()`, with the addition of one additional parameter, `focalDistance` that selects which plane in the perspective view frustum should be used to calculate the size of the orthographic view box.\n\n* `Matrix4.orthographic({fovy, aspect, focalDistance, near, far})`\n\n\n## About Projection Matrices\n\nAn ortograhic projection matrix essentially just scales your view to show everything within a box. As can be seen in the matrix below, it just centers your view between the bounds of the box, and scales your positions so that the box limits fall on -1 and +1 in each direction. It also does an inversion of the X and Y coordinates.\n\n<math display=\"block\">\n  <mrow>\n    <mfenced open=\"[\" close=\"]\">\n    <mtable>\n      <mtr>\n        <mtd columnalign=\"center\"><msub><mi>scale</mi><mn>x</mn></msub></mtd>\n        <mtd columnalign=\"center\"><mi>...</mi></mtd>\n        <mtd columnalign=\"center\"><mi>...</mi></mtd>\n        <mtd columnalign=\"center\"><msub><mi>translate</mi><mi>x</mi></msub></mtd>\n      </mtr>\n      <mtr>\n        <mtd columnalign=\"center\"><mi>...</mi></mtd>\n        <mtd columnalign=\"center\"><msub><mi>scale</mi><mn>y</mn></msub></mtd>\n        <mtd columnalign=\"center\"><mi>...</mi></mtd>\n        <mtd columnalign=\"center\"><msub><mi>translate</mi><mi>y</mi></msub></mtd>\n      </mtr>\n      <mtr>\n        <mtd columnalign=\"center\"><mi>...</mi></mtd>\n        <mtd columnalign=\"center\"><mi>...</mi></mtd>\n        <mtd columnalign=\"center\"><msub><mi>scale</mi><mn>z</mn></msub></mtd>\n        <mtd columnalign=\"center\"><msub><mi>translate</mi><mi>z</mi></msub></mtd>\n      </mtr>\n      <mtr>\n        <mtd columnalign=\"center\"><mi>...</mi></mtd>\n        <mtd columnalign=\"center\"><mi>...</mi></mtd>\n        <mtd columnalign=\"center\"><mi>...</mi></mtd>\n        <mtd columnalign=\"center\"><msub><mi>scale</mi><mi>global</mi></msub></mtd>\n      </mtr>\n    </mtable>\n    </mfenced>\n\n    <mo>=</mo>\n\n    <mfenced open=\"[\" close=\"]\">\n    <mtable>\n      <mtr>\n        <mtd columnalign=\"center\"><mfrac><mn>-2</mn><mi>left - right</mi></mfrac></mtd>\n        <mtd columnalign=\"center\"><mn>0</mn></mtd>\n        <mtd columnalign=\"center\"><mn>0</mn></mtd>\n        <mtd columnalign=\"center\"><mfrac><mi>left + right</mi><mi>left - right</mi></mfrac></mtd>\n      </mtr>\n      <mtr>\n        <mtd columnalign=\"center\"><mn>0</mn></mtd>\n        <mtd columnalign=\"center\"><mfrac><mn>-2</mn><mi>bottom - top</mi></mfrac></mtd>\n        <mtd columnalign=\"center\"><mn>0</mn></mtd>\n        <mtd columnalign=\"center\"><mfrac><mi>bottom + top</mi><mi>bottom - top</mi></mfrac></mtd>\n      </mtr>\n      <mtr>\n        <mtd columnalign=\"center\"><mn>0</mn></mtd>\n        <mtd columnalign=\"center\"><mn>0</mn></mtd>\n        <mtd columnalign=\"center\"><mfrac><mn>2</mn><mi>near - far</mi></mfrac></mtd>\n        <mtd columnalign=\"center\"><mfrac><mi>near + far</mi><mi>near - far</mi></mfrac></mtd>\n      </mtr>\n      <mtr>\n        <mtd columnalign=\"center\"><mn>0</mn></mtd>\n        <mtd columnalign=\"center\"><mn>0</mn></mtd>\n        <mtd columnalign=\"center\"><mn>0</mn></mtd>\n        <mtd columnalign=\"center\"><mn>1</mn></mtd>\n      </mtr>\n    </mtable>\n    </mfenced>\n  </mrow>\n</math>\n\n\n## Decomposing a ViewProjection Matrix\n\nTBA\n\n\n## Remarks\n\n* As always, matrices are presented here in row major notation, however math.gl stores them internally in column major format to match WebGL requirements.\n\n","slug":"modules/core/docs/developer-guide/view-and-projection","title":" View and Projection Matrices"},{"excerpt":"Polygon (Experimental) Note this class is experimental and may change or be removed in minor math.gl versions. Allows an array of points…","rawMarkdownBody":"# Polygon (Experimental)\n\n> Note this class is experimental and may change or be removed in minor math.gl versions.\n\nAllows an array of points (whether closed or non-closed) to be treated as a Polygon.\n\nImplements the [Shoelace formula](https://en.wikipedia.org/wiki/Shoelace_formula) for determining the area and winding direction of an arbitrary polygon.\n\n## Usage\n\n```js\nimport {_Polygon as Polygon} from 'math.gl';\n```\n\n\n## Methods\n\n#### constructor\n\nCreates a new Polygon object.\n\n> The polygon object will reference the provided points, assuming them to not be modified for the lifetime of the Polygon object.\n\n\n#### getSignedArea\n\nReturns the area with a sign indicating the winding direction.\n\n`polygon.getSignedArea()`\n\n\n#### getArea\n\n`polygon.getArea()`\n\nNote:\n* A convenience method that returns `Math.abs(polygon.getSignedArea())`.\n\n\n#### getWindingDirection\n\nReturns the direction of the polygon path.\n\n`polygon.getWindingDirection()`\n\n* A positive number is clockwise.\n* A negative number is counter clockwise.\n\nNote:\n* A convenience method that returns `Math.sign(polygon.getSignedArea())`\n\n\n#### forEachSegment\n\nLets the application iterate over each segment.\n\n`polygon.forEachSegment((p1, p2) => ...);`\n\n\n## Remarks\n\n* To avoid having to copy a non-closed path to be able to treat it as a polygon (by adding a copy of the first vertex to then end of the path),\ninstead we define a `forEachSegment` iteration method that makes sure the last segment is iterated over.\n\n","slug":"modules/core/docs/api-reference/addons/polygon","title":"Polygon (Experimental)"},{"excerpt":"3D Rotations Note: This article is a work in progress and may contain incorrect information. math.gl provides a \"standard 3D library…","rawMarkdownBody":"# 3D Rotations\n\n> Note: This article is a work in progress and may contain incorrect information.\n\nmath.gl provides a \"standard 3D library complement\" of mathematical classes for handling rotations in 2D and 3D, such as classes for manipulating `Euler` angles and `Quaternion`s. As in any 3D math library, the key goals are enabling applications to easily and intuitively specify (parametrize) rotations, combine them with other rotations and other transformations, and ultimately transform points with the rotations or resulting transformations.\n\nWhile math.gl is intended to help programmers' implement the typical 3D application's rotation functionality with a minimum amount of knowledge, and does not even attempt to support rotations in more than 3 dimensions, it should be pointed out that the mathematical treatment of rotations can be very complicated. For some context on this see the background section at the end of this article.\n\n\n### Properties of 3D Rotations\n\n* In contrast to 2D rotations, 3D rotations are not order-independent, meaning that applying the same two rotations in different order will often yield different results.\n* However, by [Euler's Rotation Theorem](https://en.wikipedia.org/wiki/Euler%27s_rotation_theorem), two 3D rotations around the origin can always be expressed as (combined into) another single 3D rotation around the origin.\n* A 3D rotation requires a minimum of three values to be fully specified (and even then can require careful definitions of which conventions are used).\n\nAlso, a simple observation: Rotations around arbitrary points can be treated as rotations around the origin simply by applying a translation before the rotation, and the inverse translation after the rotation. Therefore, for simplicity, this discussion focuses solely on rotations around the origin.\n\n\n## Parametrizing 3D Rotations\n\nA minimum of three values are required to fully specify a 3D rotation (another result of Euler's), e.g, Euler angles or unit quaternions.\n\nHowever in many cases the best way to specify a rotation is to use four parameters: an axis and an angle.\n\n\n| Representation | Interpolation | Addition  | Transforming points |\n| ---            | ---           | ---       | ---       |\n| Vector/Angle   | -             | -         | Good      |\n| Quaternion     | Excellent     | Excellent | Good      |\n| 4x4 Matrix     | -             | Excellent | Excellent |\n| Euler angle    | -             | -         | -         |\n\n\n### Rotation Axis and Angle\n\nPer the Euler Rotation Theorem, any two 3D rotations can be combined into a single 3D rotation. A single 3D rotation happens around an axis, and the rotation is a certain angle. This means that it is possible to specify a rotation using four very understanable values: an axis and an angle.\n\n### Euler Angles\n\nOne of the more \"human readable\" representation of a 3D rotation is the \"Euler angle\", simplistically, an \"Euler angle\" completely specifies a rotation using only 3 values, which are all \"human readable\" angles around the three coordinate axes, which is very appealing.\n\nHowever, the conventions for [Euler angle values](https://en.wikipedia.org/wiki/Euler_angles) can vary in a number of ways. Following three.js, the math.gl `Euler` class uses intrinsic Tait-Bryan angles.\n\nNote that the large number of representations means that Euler angles exchanged between e.g. different software systems may not be directly compatible (and in addition, converting between the various representations is not exactly easy), so unless care is taken this can cause \"mind-numbing\" confusion.\n\nBecause of the variability, a good approach is often to be extremely careful when importing and exporting Euler angles from your code, and convert angle Euler angles to Matrix or Quaternion representations (which are much less ambiguous) for further manipulation.\n\n\n### Unit Quaternions\n\n\"Unit quaternions\" are normally the best representation for \"manipulation\" of 3D rotations. Manpulation here mainly refers to the \"composition\" or \"addition\" and interpolation of rotations.\n\nNote that unit quaternions are simply quaternions of norm (or length) equal to `1`, and while a general quaternion (as the name suggests) contains four components, a unit quaternion needs only three values to be fully specified.\n\nUnit quaternions can be used to model 3 dimensional rotations.\n\nqr*v*qr-1\n\nInterpolation of quaternions is done using Spherical Linear intERPolation (aka SLERP).\n\n\n## Rotation Matrices\n\nWhen combining rotations with other transformations (translations, scalings, projections etc), 4x4 matrices are the representation of choice.\n\n## Properties of Rotation Matrices\n\nA rotation matrix\n\n  T\nRR  = I\n\nNote that a matrix R satisfying this can also include an inversion (improper rotation matrix)\n\n\n## Converting between Rotation Representations\n\n```js\nnew Euler();\nnew Euler();\n```\n\n## Executing Rotation Transformations\n\nWhile Euler angles are often a good way to specify 3D rotations, they can not directly be used to transfor points or vectors. To do that, they have to be converted to . \n\n\n## Rotations using Rotation Matrices\n\nA rotation matrix\n\n  T\nRR  = I\n\n\n\n## Combining Rotations\n\nThe fact that rotations. They can either be combined as w\n\nMath with Euler Angles\n\nMath with Quaternions\n\n\n## Interpolating Rotations\n\nTo avoid issues with gimbal locks and flips, it is recommended to use quaternions when interpolating rotations.\n\nCalculate the quaternion that represents the rotation you want to apply (e.g. moves the start rotation to the target rotation), and then just interpolate q with the identity quaternion using `slerp()`. The resulting quaternion can then be used directly to transform `Vector`s or it can be transformed into a `Matrix4` transformation matrix.\n\n```js\n  const qUnit = new Quaternion();\n  const qTarget = new Quaternion(...);\n\n  for (let ratio = 0; ratio < 1.0; ratio += 0.1) {\n  \tconst qInterpolated = new Quaternion().slerp(qUnit, qTarget, ratio);\n  }\n```\n\n## Background: Rotations are Complicated\n\nIf you are new to working with rotations and the amount of complications outlined in this article seem overwhelming, take some comfort in the fact that rotations in three and higher dimensional spaces are indeed quite complicated to treat mathematically.\n\nAs an example, several fundamental properties of rotations are highly dependent on the number of dimensions involved. To help the reader who has not worked extensively with rotations build some \"intuition\" for the fact that 3D rotations are non-trivial, the following summary shows how the nice, structured properties of 2D rotations gradually disappear as the number of dimensions increase:\n\n* In two dimensions, rotations are highly structured and intuitive:\n    * A series of 2D rotations can be applied in any order (they commute).\n    * Any 2D rotation can be fully parametrized by a single value (the \"angle\").\n    The combination of two 2D rotations can always be expressed as another single rotation (simply by taking the sum of the angles of the two rotations).\n* In three dimensions rotation start to loose some structure:\n\t* In 3D, rotations are no longer order-independent (they are not commutative), meaning that applying the same two rotations in different order will often yield different results.\n\t* However, by [Euler's Rotation Theorem](https://en.wikipedia.org/wiki/Euler%27s_rotation_theorem), two 3D rotations around the origin can still always be expressed as (combined into) another single 3D rotation around the origin.\n\t* Also, a 3D rotation requires not two, but a minimum of three values to be fully specified.\n* To give some contrast, in four and higher dimensions:\n    * Naturally, rotations still no longer commutative.\n    * And worse: Euler's Rotation Theorem no longer holds. There are now two different types of basic rotations, and the combination of two rotations will in general not result in another \"rotation\", but another, more complex transformation.\n    * In addition, the number of parameters (degrees of freedom) required to fully specify a rotation grows with mind-boggling rapidity, as 2^(n-1) - 1, meaning that e.g. a \"21 dimensional rotation\" would require over one million values to be fully specified!\n\n\n## Background: More on Euler Angles\n\n[Euler angle values](https://en.wikipedia.org/wiki/Euler_angles)\n\n* **Axis Order** - the order of rotations needs to be defined. There are 6 ways to order rotations around the three axis.\n* **Choice of Axes** - \"Classic Euler\" angles follow a Z-Y-Z, convention, rotating around the same angle first and last. However, in modern applications (e.g. Aerospace and Nautical), the \"Tait-Brya\"\n* **Intrinsic or Extrinsic** - One one also needs to define whether the angles are intrinsic or extrinsic.\nAs a comparison:\n* three.js `Euler` class uses intrinsic Tait-Bryan angles. \"Intrinsic\" means that rotations are performed with respect to the local coordinate system. That is, for order 'XYZ', the rotation is first around the local-X axis (which is the same as the world-X axis), then around local-Y (which may now be different from the world Y-axis), then local-Z (which may be different from the world Z-axis).\n\n\n## Remarks\n\n* In this article, the word \"axes\" represents the plural of a (coordinate) \"axis\" (normally, the word \"axes\" refers to the X, Y and Z coordinate axes).\n* **Note** that one of the most efficient way to specify rotations is to use the Euler-Rodrigues parameters, which has some of the quaternion representation without requiring the introduction of quaternion algebra. math.gl does not directly support this representation though although the vector/angle can easily be converted.\n\n","slug":"modules/core/docs/developer-guide/concepts/rotations","title":"3D Rotations"},{"excerpt":"About Homogeneous Coordinates This article is a work in progress and may contain incorrect information. The math.gl  class is not normally…","rawMarkdownBody":"# About Homogeneous Coordinates\n\n> This article is a work in progress and may contain incorrect information.\n\n\nThe math.gl `Vector4` class is not normally used to represent four dimensonal points. Instead it is intended to be used to calculate with 3 dimensonal **homogeneous coordinates**, as defined by projective geometry.\n\nMathematically, in projective geometry, each `Vector4` is interpreted as a point on a 3D line through the origin. And it is this line that is the primary object, in the sense that the point is only considered to be one of infinintely many \"representatives\" of that a line through the origin. Dividing `xyz` with the same number will generate another point, or 'representative' of the same line\n\nThe main reason homogeneous coordinates and projective geometry are used in 3D graphics programming is that they allow perspective projection and translations to be represented as linear transformations using 4x4 matrices.\n\n\n### The W Coordinate\n\nMathematically, homogeneous coordinates add one extra dimension to represent a number. In the 3 dimensional computer graphics case, it is customary to refer to the extra (4th) components as `w`. Mathematically, the `w` coordinate indicates which representative along the projective line.\n\nThere is a straightforward graphical interpretation of the `w` coordinate: During projection of a set of homogeneous vectors onto a plane at distance 1 from the origin, all the vectors are normalized so that their `w` coordinates are `1` by dividing `xyz` with `w`. which leads to the following graphical interpretation:\n\n| `w`     | Graphical Interpretation  |\n| ---     | --- |\n| > `1`   | your object will look smaller |\n| < `1`   | your object will look bigger |\n| = `0`   | will cause a crash or undefined behavior |\n| < `0`   | will flip your object (upside-down, back-to-front, ...) |\n\nBoth math.gl and typical GPUs do not support calculations on homogeneous coordinates with a `w` component of zero. (However, zero `w`coordinates play a very important role in general projective geometry, see \"Background\" below).\n\n\n## Practical Usage\n\n### Projective Transformation\n\nA general projective transformation matrix has the following format\n\n<math display=\"block\">\n  <mrow>\n    <mfenced open=\"[\" close=\"]\">\n      <mtable>\n        <mtr>\n          <mtd columnalign=\"center\"><msub><mi>c</mi><mn>0</mn></msub></mtd>\n          <mtd columnalign=\"center\"><msub><mi>c</mi><mn>1</mn></msub></mtd>\n          <mtd columnalign=\"center\"><msub><mi>c</mi><mn>2</mn></msub></mtd>\n          <mtd columnalign=\"center\"><msub><mi>proj</mi><mi>x</mi></msub></mtd>\n        </mtr>\n        <mtr>\n          <mtd columnalign=\"center\"><msub><mi>c</mi><mn>1</mn></msub></mtd>\n          <mtd columnalign=\"center\"><msub><mi>c</mi><mn>2</mn></msub></mtd>\n          <mtd columnalign=\"center\"><msub><mi>c</mi><mn>3</mn></msub></mtd>\n          <mtd columnalign=\"center\"><msub><mi>proj</mi><mi>y</mi></msub></mtd>\n        </mtr>\n        <mtr>\n          <mtd columnalign=\"center\"><msub><mi>c</mi><mn>2</mn></msub></mtd>\n          <mtd columnalign=\"center\"><msub><mi>c</mi><mn>3</mn></msub></mtd>\n          <mtd columnalign=\"center\"><msub><mi>c</mi><mn>4</mn></msub></mtd>\n          <mtd columnalign=\"center\"><msub><mi>proj</mi><mi>z</mi></msub></mtd>\n        </mtr>\n        <mtr>\n          <mtd columnalign=\"center\"><msub><mi>trans</mi><mi>x</mi></msub></mtd>\n          <mtd columnalign=\"center\"><msub><mi>trans</mi><mi>y</mi></msub></mtd>\n          <mtd columnalign=\"center\"><msub><mi>trans</mi><mi>z</mi></msub></mtd>\n          <mtd columnalign=\"center\"><msub><mi>scale</mi><mi>global</mi></msub></mtd>\n        </mtr>\n      </mtable>\n    </mfenced>\n\n    <mo>.</mo>\n\n    <mfenced open=\"[\" close=\"]\">\n      <mtable>\n        <mtr><mtd columnalign=\"center\"><mi>x</mi></mtd></mtr>\n        <mtr><mtd columnalign=\"center\"><mi>y</mi></mtd></mtr>\n        <mtr><mtd columnalign=\"center\"><mi>z</mi></mtd></mtr>\n        <mtr><mtd columnalign=\"center\"><mi>w</mi></mtd></mtr>\n      </mtable>\n    </mfenced>\n  </mrow>\n</math>\n\n\n### Translation of 3D coordinates\n\nLinear transformations on a vector space can not move the origin, they can only scale and rotate.\n\nTranslations leave the `w` coordinate unchanged.\n\nAs can be seen in the general format of the projection matrix, setting `w` to 0 prevents a vector from picking up the translations when multiplied with a 4x4 matrix. (easy to see as the translations are stored in the final column of the transposed matrix)\n\n\n### Perspective Transformation\n\nNote that in general, a perspective transformation (i.e. multipliying) do change the `w` coordinate of the `Vector4`, so vectors must be \"scaled\" after transformation when used in JavaScript.\n\nGPU Note: the GPU automatically divides `vec4` `xyz` components with `w` when they are returned from the vertex shader (when homogeneous coordinates are returned from the vertex shader (typically by assigning a `vec4` to `gl_Position`). This can be an important detail to be aware of when comparing JavaScript and GLSL code, and also when working in screen space (post-projection) in the vertex shader, in which case you typically do need to perform the `w` scaling yourself.\n\n\n## Background Information\n\nSome fun facts to provide additional context around homogeneous coordinates.\n\nProjective geometry was coordinatized (in the form or homogeneous coordinates) in the early 1800s by Plücker and Möbius, almost 200 years after the coordinatization of \"affine\" geometry by Descartes.\n\nThere is a special **notation** for homogeneous coordinate vectors that emphasizes the relative aspect of the values:\n\n<math>\n  <mfenced open=\"[\" close=\"]\" separators=\":::\">\n    <mi>x</mi><mi>y</mi><mi>z</mi>\n  </mfenced>\n</math>\n\nHowever, in mathematics, one of the most important aspects of projective geometry is that it can be used to avoid handling of **special cases** (this aspect is not used in math.gl). Essentially, in contrast to line equations in affine geometry, projective geometry allows parallel lines to be represented by adding a set of additional points in the form of a \"plane at infinity\" (which is represented by `w`=`0`). This is powerful as it makes it possible to e.g. make statements about geometry (such as two lines always meet in one point) without having to make tedious exceptions for parallel lines.\n","slug":"modules/core/docs/developer-guide/concepts/homogeneous-coordinates","title":"About Homogeneous Coordinates"},{"excerpt":"Vector2 A two dimensional vector Usage Inheritance  extends  extends  extends  Many commonly used  methods are inherited from  and…","rawMarkdownBody":"# Vector2\n\nA two dimensional vector\n\n\n## Usage\n\n```js\nimport {Vector2} from 'math.gl';\nconst vector = new Vector2(1, 1);\n```\n\n## Inheritance\n\n`Vector2` extends [`Vector`](./docs/api-reference/vector) extends [`MathArray`](./docs/api-reference/math-array) extends [`Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)\n\nMany commonly used `Vector2` methods are inherited from `Vector` and `MathArray`:\n\n* `Vector2.clone()`\n* `Vector2.copy(array)`\n* `Vector2.set(...args)`\n* `Vector2.fromArray(array, offset = 0)`\n* `Vector2.toString()`\n* `Vector2.toArray(array = [], offset = 0)`\n* `Vector2.equals(array)`\n* `Vector2.exactEquals(array)`\n* `Vector2.validate(array = this)`\n* `Vector2.check(array = this)`\n* `Vector2.normalize()`\n\nAlso note that `Vector2` is a subclass of the built in JavaScript `Array` and can thus be used wherever an Array is expected. It can e.g. supplied as a parameter to any function expecting an `Array`.\n\n\n##  Members\n\n### x, y\n\nGets or sets element 0 or 1 respectively\n\n### constructor\n\nCreates a new, empty `Vector2`, or copies an existing `Vector2`\n\n```js\nconstructor(x = 0, y = 0)\nconstructor([x, y])\n```\n\n\n### set\n\n`set(x, y)`\n\n\n### add\n\nAdd zero or more vectors to current vector.\n\n`add(...vectors)`\n\n\n### subtract\n\nSubtract zero or more vectors from current vector\n\n`subtract(...vectors)`\n\n\n### multiply\n\nMultiply zero or more vectors with current vector\n\n`multiply(...vectors)`\n\n\n### divide\n\nDivide zero or more vectors with current vector\n\n`divide(...vectors)`\n\n\n### scale\n\n`scale(scale)`\n\n\n### scaleAndAdd\n\n`scaleAndAdd(vector, scale)`\n\n\n### negate\n\n`negate()`\n\n\n### normalize\n\n`normalize()`\n\n\n### dot\n\n`dot(vector)`\n\n\n### lerp\n\n`lerp(vector, coeff)`\n\n\n### horizontalAngle\n\nCalculates counterclockwise angle in radians starting from positive x axis\n\n`horizontalAngle()`\n\nNote: returns `Math.atan2(this.y, this.x)`\n\n\n### verticalAngle\n\nCalculates clockwise angle in radians starting from positive y axis\n\n`verticalAngle()`\n\nNote: returns `Math.atan2(this.x, this.y)`\n\n### transform(matrix4 : Number[16]) : Vector4\n\nEquivalent to `transformAsPoint`.\n\n### transformAsPoint(matrix4 : Number[16]) : Vector4\n\nTransforms this vector by the provided 4x4 matrix as a point (i.e includes translations).\n\nNote: Implicitly extends the vector to `[x, y, 0, 1]` before applying the 4x4 transformation.\n\n### transformAsVector(matrix4 : Number[16]) : Vector4\n\nTransforms this vector by the provided 4x4 matrix as a vector (i.e does not include translations).\n\nNote: Implicitly extends the vector to `[x, y, 0, 0]` before applying the 4x4 transformation.\n\n### transformByMatrix3(matrix3 : Number[9]) : Vector4\n\nTransforms this vector by the provided 3x3 matrix.\n\n### transformByMatrix2x3(matrix2 : Number[6]) : Vector4\n\nTransforms this vector  by the provided 2x3 matrix (A pure 2D transform that can incorporate translations).\n\n### transformByMatrix2(matrix2 : Number[4]) : Vector4\n\nTransforms this vector by the provided 2x2 matrix.\n","slug":"modules/core/docs/api-reference/vector2","title":"Vector2"},{"excerpt":"Euler (Experimental) Note this class is experimental and may change or be removed in minor math.gl versions. A class to handle Euler…","rawMarkdownBody":"# Euler (Experimental)\n\n> Note this class is experimental and may change or be removed in minor math.gl versions.\n\n```js\nclass Euler extends MathArray extends Array\n```\n\nA class to handle Euler rotation. More information on rotation using a Euler vector can be found [here](https://en.wikipedia.org/wiki/Euler%27s_rotation_theorem). Generally speaking the three components of the Euler object represents the roll, pitch and yaw angles and the rotation is applied according to a specific rotation order.\n\n\n## Usage\n\n```js\nimport {_Euler as Euler} from 'math.gl'\n```\n\n## Constants\n\n* `Euler.ZYX`\n* `Euler.YXZ`\n* `Euler.XZY`\n* `Euler.ZXY`\n* `Euler.YZX`\n* `Euler.XYZ`\n* `Euler.RollPitchYaw`\n\n* `Euler.DefaultOrder` (= `Euler.ZYX`)\n* `Euler.RotationOrders` =  `['ZYX', 'YXZ', 'XZY', 'ZXY', 'YZX', 'XYZ']`;\n\n## Members\n\n### x, y z\n\nx, y, z angle notation (note: only corresponds to axis in XYZ orientation)\n\n### roll, pitch, yaw\n\nroll, pitch, yaw angle notation\n\n### alpha, beta, gamma\n\nalpha, beta, gamma angle notation\n\n### phi, theta, psi\n\nphi, theta, psi angle notation\n\n### order\n\nrotation order in all notations\n\n\n## Methods\n\n### constructor\n\n(x = 0, y = 0, z = 0, order = Euler.DefaultOrder)\n * Number|Number[], Number, Number, Number\n\n\n### fromRollPitchYaw\n\nCommon ZYX rotation order\n\n`euler.fromRollPitchYaw(roll, pitch, yaw)`\n\n\n### fromRotationMatrix\n\n`euler.fromRotationMatrix(m, order = Euler.DefaultOrder)`\n\n\n### fromQuaternion\n\n`euler.fromQuaternion(q, order)`\n\n\n### copy\n\nIf copied array does contain fourth element, preserves currently set order.\n\n`euler.copy(array)`\n\n\n### set\n\nSets the three angles, and optionally sets the rotation order. If order is not specified, preserves currently set order.\n\n`euler.set(x = 0, y = 0, z = 0, order)`\n\n\n### toArray\n\nDoes not copy the orientation element\n\n`euler.toArray(array = [], offset = 0)`\n\n\n### toArray4\n\nCopies the orientation element\n\n`euler.toArray4(array = [], offset = 0)`\n\n\n### toVector3\n\n`euler.toVector3(optionalResult)`\n\n\n### fromVector3\n\n`euler.fromVector3(v, order)`\n\n\n### fromArray\n\n`euler.fromArray(array, offset = 0)`\n\n\n### getRotationMatrix\n\n`euler.getRotationMatrix(m = new Matrix4())`\n\nReturns `Matrix4` - a rotation matrix corresponding to rotations per the specified euler angles\n\n\n### getQuaternion\n\n`euler.getQuaternion()`\n\n\n## Remarks\n\n* Attribution: inspired by THREE.js `THREE.Euler` class\n","slug":"modules/core/docs/api-reference/euler","title":"Euler (Experimental)"}]}}}